<HTML>
<HEAD>
<TITLE>Nirvana Editor (NEdit) Help Documentation</TITLE>
</HEAD>
<BODY>
<P>
<A NAME="Nirvana_Editor_(NEdit)_Help_Documentation"</A>
<H1> Nirvana Editor (NEdit) Help Documentation </H1>
<P>
<A NAME="Table_of_Contents"</A>
<H2> Table of Contents </H2>
<P>
<PRE>
    <A HREF="#Getting_Started">Getting Started</A>                    
</PRE>
<P>
<PRE>
    Basic Operation                     Macro/Shell Extensions
      <A HREF="#Selecting_Text">Selecting Text</A>                      <A HREF="#Shell_Commands_and_Filters">Shell Commands and Filters</A>
      <A HREF="#Finding_and_Replacing_Text">Finding and Replacing Text</A>          <A HREF="#Learn/Replay">Learn/Replay</A>
      <A HREF="#Cut_and_Paste">Cut and Paste</A>                       <A HREF="#Macro_Language">Macro Language</A>
      <A HREF="#Using_the_Mouse">Using the Mouse</A>                     <A HREF="#Macro_Subroutines">Macro Subroutines</A>
      <A HREF="#Keyboard_Shortcuts">Keyboard Shortcuts</A>                  <A HREF="#Highlighting_Information">Highlighting Information</A>
      <A HREF="#Shifting_and_Filling">Shifting and Filling</A>                <A HREF="#Range_Sets">Range Sets</A>
      <A HREF="#File_Format">File Format</A>                         <A HREF="#Action_Routines">Action Routines</A>
                                        Customizing
    Features for Programming              <A HREF="#Customizing_NEdit">Customizing NEdit</A>
      <A HREF="#Programming_with_NEdit">Programming with NEdit</A>              <A HREF="#Preferences">Preferences</A>
      <A HREF="#Tabs/Emulated_Tabs">Tabs/Emulated Tabs</A>                  <A HREF="#X_Resources">X Resources</A>
      <A HREF="#Auto/Smart_Indent">Auto/Smart Indent</A>                   <A HREF="#Key_Binding">Key Binding</A>
      <A HREF="#Syntax_Highlighting">Syntax Highlighting</A>                 <A HREF="#Highlighting_Patterns">Highlighting Patterns</A>
      <A HREF="#Finding_Declarations_(ctags)">Finding Declarations (ctags)</A>        <A HREF="#Smart_Indent_Macros">Smart Indent Macros</A>
      <A HREF="#Calltips">Calltips</A>
</PRE>
<P>
<PRE>
    Regular Expressions                 <A HREF="#NEdit_Command_Line">NEdit Command Line</A>
      <A HREF="#Basic_Regular_Expression_Syntax">Basic Regular Expression Syntax</A>   <A HREF="#Client/Server_Mode">Client/Server Mode</A>
      <A HREF="#Metacharacters">Metacharacters</A>                    <A HREF="#Crash_Recovery">Crash Recovery</A>
      <A HREF="#Parenthetical_Constructs">Parenthetical Constructs</A>          <A HREF="#Version">Version</A>
      <A HREF="#Advanced_Topics">Advanced Topics</A>                   <A HREF="#Distribution_Policy">Distribution Policy</A>
      <A HREF="#Example_Regular_Expressions">Example Regular Expressions</A>       <A HREF="#Mailing_Lists">Mailing Lists</A>
                                        <A HREF="#Problems/Defects">Problems/Defects</A>
</PRE>
<P>
<A NAME="Getting_Started"</A>
<H2> Getting Started </H2>
<P>
Welcome to NEdit!
<P>
NEdit is a standard GUI (Graphical User Interface) style text editor for
programs and plain-text files.  Users of Macintosh and MS Windows based text
editors should find NEdit a familiar and comfortable environment.  NEdit
provides all of the standard menu, dialog, editing, and mouse support, as
well as all of the standard shortcuts to which the users of modern GUI based
environments are accustomed.  For users of older style Unix editors, welcome
to the world of mouse-based editing!
<P>
Help sections of interest to new users are listed under the "Basic Operation"
heading in the top-level Help menu:
<P>
<UL>
    <<B><font color=red>--&#62; li>Selecting Text &#60;-- NO HREF!!</font></B></li>
    <<B><font color=red>--&#62; li>Finding and Replacing Text &#60;-- NO HREF!!</font></B></li>
    <<B><font color=red>--&#62; li>Cut and Paste &#60;-- NO HREF!!</font></B></li>
    <<B><font color=red>--&#62; li>Using the Mouse &#60;-- NO HREF!!</font></B></li>
    <<B><font color=red>--&#62; li>Keyboard Shortcuts &#60;-- NO HREF!!</font></B></li>
    <<B><font color=red>--&#62; li>Shifting and Filling &#60;-- NO HREF!!</font></B></li>
</UL>
<P>
Programmers should also read the introductory section under the "Features for
Programming" section:
<P>
<PRE>
      <A HREF="#Programming_with_NEdit">Programming with NEdit</A>
</PRE>
<P>
If you get into trouble, the Undo command in the Edit menu can reverse any
modifications that you make.  NEdit does not change the file you are editing
until you tell it to Save.
<P>
<H3>Editing an Existing File</H3>
<P>
To open an existing file, choose Open... from the file menu. Select the file
that you want to open in the pop-up dialog that appears and click on OK.  You
may open any number of files at the same time.  Each file will appear in its
own editor window.  Using Open... rather than re-typing the NEdit command and
running additional copies of NEdit, will give you quick access to all of the
files you have open via the Windows menu, and ensure that you don't
accidentally open the same file twice.  NEdit has no "main" window.  It
remains running as long as at least one editor window is open.
<P>
<H3>Creating a New File</H3>
<P>
If you already have an empty (Untitled) window displayed, just begin typing
in the window.  To create a new Untitled window, choose New from the File
menu.  To give the file a name and save its contents to the disk, choose Save
or Save As... from the File menu.
<P>
<H3>Backup Files</H3>
<P>
NEdit maintains periodic backups of the file you are editing so that you can
recover the file in the event of a problem such as a system crash, network
failure, or X server crash.  These files are saved under the name `~filename`
(on Unix) or `_filename` (on VMS), where filename is the name of the file you
were editing.  If an NEdit process is killed, some of these backup files may
remain in your directory.  (To remove one of these files on Unix, you may
have to prefix the `~' (tilde) character with a (backslash) to prevent the
shell from interpreting it as a special character.)
<P>
<H3>Shortcuts</H3>
<P>
As you become more familiar with NEdit, substitute the control and function
keys shown on the right side of the menus for pulling down menus with the
mouse.
<P>
Dialogs are also streamlined so you can enter information quickly and without
using the mouse*.  To move the keyboard focus around a dialog, use the tab
and arrow keys.  One of the buttons in a dialog is usually drawn with a
thick, indented, outline.  This button can be activated by pressing Return or
Enter.  The Cancel or Dismiss button can be activated by pressing escape. 
For example, to replace the string "thing" with "things" type:
<P>
<PRE>
      &#60;ctrl-r&#62;thing&#60;tab&#62;things&#60;return&#62;
</PRE>
<P>
To open a file named "whole_earth.c", type:
<P>
<PRE>
      &#60;ctrl-o&#62;who&#60;return&#62;
</PRE>
<P>
(how much of the filename you need to type depends on the other files in the
directory).  See the section called "<A HREF="#Keyboard_Shortcuts">Keyboard Shortcuts</A>" for more details.
<P>
* Users who have set their keyboard focus mode to "pointer" should set
"Popups Under Pointer" in the Default Settings menu to avoid the additional
step of moving the mouse into the dialog.
<P><HR>
<P>
<A NAME="Basic_Operation"</A>
<H1> Basic Operation </H1>
<P>
<A NAME="Selecting_Text"</A>
<H2> Selecting Text </H2>
<P>
NEdit has two general types of selections, primary (highlighted text), and
secondary (underlined text). Selections can cover either a simple range of
text between two points in the file, or they can cover a rectangular area of
the file. Rectangular selections are only useful with non-proportional (fixed
spacing) fonts.
<P>
To select text for copying, deleting, or replacing, press the left mouse
button with the pointer at one end of the text you want to select, and drag
it to the other end. The text will become highlighted. To select a whole
word, double click (click twice quickly in succession). Double clicking and
then dragging the mouse will select a number of words. Similarly, you can
select a whole line or a number of lines by triple clicking or triple
clicking and dragging. Quadruple clicking selects the whole file. After
releasing the mouse button, you can still adjust a selection by holding down
the shift key and dragging on either end of the selection. To delete the
selected text, press delete or backspace. To replace it, begin typing.
<P>
To select a rectangle or column of text, hold the Ctrl key while dragging the
mouse. Rectangular selections can be used in any context that normal
selections can be used, including cutting and pasting, filling, shifting,
dragging, and searching. Operations on rectangular selections automatically
fill in tabs and spaces to maintain alignment of text within and to the right
of the selection. Note that the interpretation of rectangular selections by
Fill Paragraph is slightly different from that of other commands, the section
titled "<A HREF="#Shifting_and_Filling">Shifting and Filling</A>" has details.
<P>
The middle mouse button can be used to make an additional selection (called
the secondary selection). As soon as the button is released, the contents of
this selection will be copied to the insert position of the window where the
mouse was last clicked (the destination window). This position is marked by a
caret shaped cursor when the mouse is outside of the destination window.  If
there is a (primary) selection, adjacent to the cursor in the window, the new
text will replace the selected text. Holding the shift key while making the
secondary selection will move the text, deleting it at the site of the
secondary selection, rather than copying it.
<P>
Selected text can also be dragged to a new location in the file using the
middle mouse button. Holding the shift key while dragging the text will copy
the selected text, leaving the original text in place. Holding the control
key will drag the text in overlay mode.
<P>
Normally, dragging moves text by removing it from the selected position at
the start of the drag, and inserting it at a new position relative to to the
mouse. Dragging a block of text over existing characters, displaces the
characters to the end of the selection. In overlay mode, characters which are
occluded by blocks of text being dragged are simply removed. When dragging
non-rectangular selections, overlay mode also converts the selection to
rectangular form, allowing it to be dragged outside of the bounds of the
existing text.
<P>
The section "<A HREF="#Using_the_Mouse">Using the Mouse</A>" sumarizes the mouse commands for making primary
and secondary selections. Primary selections can also be made via keyboard
commands, see "<A HREF="#Keyboard_Shortcuts">Keyboard Shortcuts</A>".
<P><HR>
<P>
<A NAME="Finding_and_Replacing_Text"</A>
<H2> Finding and Replacing Text </H2>
<P>
The Search menu contains a number of commands for finding and replacing text.
<P>
The Find... and Replace... commands present dialogs for entering text for
searching and replacing.  These dialogs also allow you to choose whether you
want the search to be sensitive to upper and lower case, or whether to use
the standard Unix pattern matching characters (regular expressions). 
Searches begin at the current text insertion position.
<P>
Find Again and Replace Again repeat the last find or replace command without
prompting for search strings.  To selectively replace text, use the two
commands in combination: Find Again, then Replace Again if the highlighted
string should be replaced, or Find Again again to go to the next string.
<P>
Find Selection searches for the text contained in the current primary
selection (see <A HREF="#Selecting_Text">Selecting Text</A>).  The selected text does not have to be in the
current editor window, it may even be in another program.  For example, if
the word dog appears somewhere in a window on your screen, and you want to
find it in the file you are editing, select the word dog by dragging the
mouse across it, switch to your NEdit window and choose Find Selection from
the Search menu.
<P>
Find Incremental is yet another variation on searching, where every character
typed triggers a new search.  Incremental searching is generally the quickest
way to find something in a file, because it gives you the immediate feedback
of seeing how your search is progressing, so you never need to type more than
the minimally sufficient search string to reach your target.
<P>
<H3>Searching Backwards</H3>
<P>
Holding down the shift key while choosing any of the search or replace
commands from the menu (or using the keyboard shortcut), will search in the
reverse direction.  Users who have set the search direction using the buttons
in the search dialog, may find it a bit confusing that Find Again and Replace
Again don't continue in the same direction as the original search (for
experienced users, consistency of the direction implied by the shift key is
more important).
<P>
<H3>Selective Replacement</H3>
<P>
To replace only some occurrences of a string within a file, choose Replace...
from the Search menu, enter the string to search for and the string to
substitute, and finish by pressing the Find button.  When the first
occurrence is highlighted, use either Replace Again (^T) to replace it, or
Find Again (^G) to move to the next occurrence without replacing it, and
continue in such a manner through all occurrences of interest.
<P>
To replace all occurrences of a string within some range of text, select the
range (see <A HREF="#Selecting_Text">Selecting Text</A>), choose Replace... from the Search menu, type the
string to search for and the string to substitute, and press the "R. in
Selection" button in the dialog.  Note that selecting text in the Replace...
dialog will unselect the text in the window.
<P><HR>
<P>
<A NAME="Cut_and_Paste"</A>
<H2> Cut and Paste </H2>
<P>
The easiest way to copy and move text around in your file or between windows,
is to use the clipboard, an imaginary area that temporarily stores text and
data.  The Cut command removes the selected text (see <A HREF="#Selecting_Text">Selecting Text</A>) from
your file and places it in the clipboard.  Once text is in the clipboard, the
Paste command will copy it to the insert position in the current window.  For
example, to move some text from one place to another, select it by dragging
the mouse over it, choose Cut to remove it, click the pointer to move the
insert point where you want the text inserted, then choose Paste to insert
it.  Copy copies text to the clipboard without deleting it from your file. 
You can also use the clipboard to transfer text to and from other Motif
programs and X programs which make proper use of the clipboard.
<P>
There are many other methods for copying and moving text within NEdit windows
and between NEdit and other programs.  The most common such method is
clicking the middle mouse button to copy the primary selection (to the
clicked position).  Copying the selection by clicking the middle mouse button
in many cases is the only way to transfer data to and from many X programs. 
Holding the Shift key while clicking the middle mouse button moves the text,
deleting it from its original position, rather than copying it.  Other
methods for transferring text include secondary selections, primary selection
dragging, keyboard-based selection copying, and drag and drop.  These are
described in detail in the sections: "<A HREF="#Selecting_Text">Selecting Text</A>", "<A HREF="#Using_the_Mouse">Using the Mouse</A>", 
and "<A HREF="#Keyboard_Shortcuts">Keyboard Shortcuts</A>".
<P><HR>
<P>
<A NAME="Using_the_Mouse"</A>
<H2> Using the Mouse </H2>
<P>
Mouse-based editing is what NEdit is all about, and learning to use the more
advanced features like secondary selections and primary selection dragging
will be well worth your while.
<P>
If you don't have time to learn everything, you can get by adequately with
just the left mouse button:  Clicking the left button moves the cursor. 
Dragging with the left button makes a selection.  Holding the shift key while
clicking extends the existing selection, or begins a selection between the
cursor and the mouse.  Double or triple clicking selects a whole word or a
whole line.
<P>
This section will make more sense if you also read the section called,
"<A HREF="#Selecting_Text">Selecting Text</A>", which explains the terminology of selections, that is,
what is meant by primary, secondary, rectangular, etc.
<P>
<H3>Button and Modifier Key Summary</H3>
<P>
General meaning of mouse buttons and modifier keys:
<P>
<H4>  Buttons</H4>
<P>
<PRE>
      Button 1 (left)    Cursor position and primary selection
</PRE>
<P>
<PRE>
      Button 2 (middle)  Secondary selections, and dragging and
                         copying the primary selection
</PRE>
<P>
<PRE>
      Button 3 (right)   Quick-access programmable menu and pan
                         scrolling
</PRE>
<P>
<H4>  Modifier keys</H4>
<P>
<PRE>
      Shift   On primary selections, (left mouse button):
                 Extends selection to the mouse pointer
              On secondary and copy operations, (middle):
                 Toggles between move and copy
</PRE>
<P>
<PRE>
      Ctrl    Makes selection rectangular or insertion
              columnar
</PRE>
<P>
<PRE>
      Alt*    (on release) Exchange primary and secondary
              selections.
</PRE>
<P>
<H3>Left Mouse Button</H3>
<P>
The left mouse button is used to position the cursor and to make primary
selections.
<P>
<PRE>
    Click         Moves the cursor
</PRE>
<P>
<PRE>
    Double Click  Selects a whole word
</PRE>
<P>
<PRE>
    Triple Click  Selects a whole line
</PRE>
<P>
<PRE>
    Quad Click    Selects the whole file
</PRE>
<P>
<PRE>
    Shift Click   Adjusts (extends or shrinks) the
                  selection, or if there is no existing
                  selection, begins a new selection
                  between the cursor and the mouse.
</PRE>
<P>
<PRE>
    Ctrl+Shift+   Adjusts (extends or shrinks) the
    Click         selection rectangularly.
</PRE>
<P>
<PRE>
    Drag          Selects text between where the mouse
                  was pressed and where it was released.
</PRE>
<P>
<PRE>
    Ctrl+Drag     Selects rectangle between where the
                  mouse was pressed and where it was
                  released.
</PRE>
<P>
<H3>Right Mouse Button</H3>
<P>
The right mouse button posts a programmable menu for frequently used commands.
<P>
<PRE>
    Click/Drag    Pops up the background menu (programmed
                  from Preferences -&#62; Default Settings -&#62;
                  Customize Menus -&#62; Window Background).
</PRE>
<P>
<PRE>
    Ctrl+Drag     Pan scrolling.  Scrolls the window
                  both vertically and horizontally, as if
                  you had grabbed it with your mouse.
</PRE>
<P>
<H3>Middle Mouse Button</H3>
<P>
The middle mouse button is for making secondary selections, and copying and
dragging the primary selection.
<P>
<PRE>
    Click         Copies the primary selection to the
                  clicked position.
</PRE>
<P>
<PRE>
    Shift+Click   Moves the primary selection to the
                  clicked position, deleting it from its
                  original position.
</PRE>
<P>
<PRE>
    Drag          1) Outside of the primary selection:
                      Begins a secondary selection.
                  2) Inside of the primary selection:
                      Moves the selection by dragging.
</PRE>
<P>
<PRE>
    Ctrl+Drag     1) Outside of the primary selection:
                      Begins a rectangular secondary
                      selection.
                  2) Inside of the primary selection:
                      Drags the selection in overlay
                      mode (see below).
</PRE>
<P>
When the mouse button is released after creating a secondary selection:
<P>
<PRE>
    No Modifiers  If there is a primary selection,
                  replaces it with the secondary
                  selection.  Otherwise, inserts the
                  secondary selection at the cursor
                  position.
</PRE>
<P>
<PRE>
    Shift         Move the secondary selection, deleting
                  it from its original position.  If
                  there is a primary selection, the move
                  will replace the primary selection
                  with the secondary selection.
                  Otherwise, moves the secondary
                  selection to to the cursor position.
</PRE>
<P>
<PRE>
    Alt*          Exchange the primary and secondary
                  selections.
</PRE>
<P>
While moving the primary selection by dragging with the middle mouse button:
<P>
<PRE>
    Shift         Leaves a copy of the original
                  selection in place rather than
                  removing it or blanking the area.
</PRE>
<P>
<PRE>
    Ctrl          Changes from insert mode to overlay
                  mode (see below).
</PRE>
<P>
<PRE>
    Escape        Cancels drag in progress.
</PRE>
<P>
Overlay Mode: Normally, dragging moves text by removing it from the selected
position at the start of the drag, and inserting it at a new position
relative to to the mouse. When you drag a block of text over existing
characters, the existing characters are displaced to the end of the
selection.  In overlay mode, characters which are occluded by blocks of text
being dragged are simply removed.  When dragging non-rectangular selections,
overlay mode also converts the selection to rectangular form, allowing it to
be dragged outside of the bounds of the existing text.
<P>
Mouse buttons 4 and 5 are usually represented by a mouse wheel nowadays. 
They are used to scroll up or down in the text window.
<P>
* The Alt key may be labeled Meta or Compose-Character on some keyboards. 
Some window managers, including default configurations of mwm, bind
combinations of the Alt key and mouse buttons to window manager operations. 
In NEdit, Alt is only used on button release, so regardless of the window
manager bindings for Alt-modified mouse buttons, you can still do the
corresponding NEdit operation by using the Alt key AFTER the initial mouse
press, so that Alt is held while you release the mouse button.  If you find
this difficult or annoying, you can re-configure most window managers to skip
this binding, or you can re-configure NEdit to use a different key
combination.
<P><HR>
<P>
<A NAME="Keyboard_Shortcuts"</A>
<H2> Keyboard Shortcuts </H2>
<P>
Most of the keyboard shortcuts in NEdit are shown on the right hand sides of
the pull-down menus.  However, there are more which are not as obvious.  These
include; dialog button shortcuts; menu and dialog mnemonics; labeled keyboard
keys, such as the arrows, page-up, page-down, and home; and optional Shift
modifiers on accelerator keys, like [Shift]Ctrl+F.
<P>
<H3>Menu Accelerators</H3>
<P>
Pressing the key combinations shown on the right of the menu items is a
shortcut for selecting the menu item with the mouse.  Some items have the shift
key enclosed in brackets, such as [Shift]Ctrl+F.  This indicates that the shift
key is optional.  In search commands, including the shift key reverses the
direction of the search.  In Shift commands, it makes the command shift the
selected text by a whole tab stop rather than by single characters.
<P>
<H3>Menu Mnemonics</H3>
<P>
Pressing the Alt key in combination with one of the underlined characters in
the menu bar pulls down that menu.  Once the menu is pulled down, typing the
underlined characters in a menu item (without the Alt key) activates that
item.  With a menu pulled down, you can also use the arrow keys to select menu
items, and the Space or Enter keys to activate them.
<P>
<H3>Keyboard Shortcuts within Dialogs</H3>
<P>
One button in a dialog is usually marked with a thick indented outline. 
Pressing the Return or Enter key activates this button.
<P>
All dialogs have either a Cancel or Dismiss button.  This button can be
activated by pressing the Escape (or Esc) key.
<P>
Pressing the tab key moves the keyboard focus to the next item in a dialog. 
Within an associated group of buttons, the arrow keys move the focus among the
buttons.  Shift+Tab moves backward through the items.
<P>
Most items in dialogs have an underline under one character in their name. 
Pressing the Alt key along with this character, activates a button as if you
had pressed it with the mouse, or moves the keyboard focus to the associated
text field or list.
<P>
You can select items from a list by using the arrow keys to move the
selection and space to select.
<P>
In file selection dialogs, you can type the beginning characters of the file
name or directory in the list to select files
<P>
<H3>Labeled Function Keys</H3>
<P>
The labeled function keys on standard workstation and PC keyboards, like the
arrows, and page-up and page-down, are active in NEdit, though not shown in the
pull-down menus.
<P>
Holding down the control key while pressing a named key extends the scope of
the action that it performs.  For example, Home normally moves the insert
cursor the beginning of a line.  Ctrl+Home moves it to the beginning of the
file. Backspace deletes one character, Ctrl+Backspace deletes one word.
<P>
Holding down the shift key while pressing a named key begins or extends a
selection.  Combining the shift and control keys combines their actions.  For
example, to select a word without using the mouse, position the cursor at the
beginning of the word and press Ctrl+Shift+RightArrow.  The Alt key modifies
selection commands to make the selection rectangular.
<P>
Under X and Motif, there are several levels of translation between keyboard
keys and the actions they perform in a program.  The "<A HREF="#Customizing_NEdit">Customizing NEdit</A>", and
"<A HREF="#X_Resources">X Resources</A>" sections of the Help menu have more information on this subject. 
Because of all of this configurability, and since keyboards and standards for
the meaning of some keys vary from machine to machine, the mappings may be
changed from the defaults listed below.
<P>
<H3>Modifier Keys (in general)</H3>
<P>
<PRE>
    Ctrl   Extends the scope of the action that the key
           would otherwise perform.  For example, Home
           normally moves the insert cursor to the beginning
           of a line. Ctrl+Home moves it to the beginning of
           the file.  Backspace deletes one character, Ctrl+
           Backspace deletes one word.
</PRE>
<P>
<PRE>
    Shift  Extends the selection to the cursor position. If
           there's no selection, begins one between the old
           and new cursor positions.
</PRE>
<P>
<PRE>
    Alt    When modifying a selection, makes the selection
           rectangular.
</PRE>
<P>
(For the effects of modifier keys on mouse button presses, see the section
titled "<A HREF="#Using_the_Mouse">Using the Mouse</A>")
<P>
<H3>All Keyboards</H3>
<P>
<PRE>
    Escape        Cancels operation in progress: menu
                  selection, drag, selection, etc.  Also
                  equivalent to cancel button in dialogs.
</PRE>
<P>
<PRE>
    Backspace     Delete the character before the cursor
</PRE>
<P>
<PRE>
    Ctrl+BS       Delete the word before the cursor
</PRE>
<P>
<PRE>
    Arrows --
</PRE>
<P>
<PRE>
      Left        Move the cursor to the left one character
</PRE>
<P>
<PRE>
      Ctrl+Left   Move the cursor backward one word
                  (Word delimiters are settable, see
                  "<A HREF="#Customizing_NEdit">Customizing NEdit</A>", and "<A HREF="#X_Resources">X Resources</A>")
</PRE>
<P>
<PRE>
      Right       Move the cursor to the right one character
</PRE>
<P>
<PRE>
      Ctrl+Right  Move the cursor forward one word
</PRE>
<P>
<PRE>
      Up          Move the cursor up one line
</PRE>
<P>
<PRE>
      Ctrl+Up     Move the cursor up one paragraph.
                  (Paragraphs are delimited by blank lines)
</PRE>
<P>
<PRE>
      Down        Move the cursor down one line.
</PRE>
<P>
<PRE>
      Ctrl+Down   Move the cursor down one paragraph.
</PRE>
<P>
<PRE>
    Ctrl+Return   Return with automatic indent, regardless
                  of the setting of Auto Indent.
</PRE>
<P>
<PRE>
    Shift+Return  Return without automatic indent,
                  regardless of the setting of Auto Indent.
</PRE>
<P>
<PRE>
    Ctrl+Tab      Insert an ASCII tab character, without
                  processing emulated tabs.
</PRE>
<P>
<PRE>
    Alt+Ctrl+&#60;c&#62;  Insert the control-code equivalent of
                  a key &#60;c&#62;
</PRE>
<P>
<PRE>
    Ctrl+/        Select everything (same as Select
                  All menu item or ^A)
</PRE>
<P>
<PRE>
    Ctrl+\        Unselect
</PRE>
<P>
<PRE>
    Ctrl+U        Delete to start of line
</PRE>
<P>
<H3>PC Standard Keyboard</H3>
<P>
<PRE>
    Ctrl+Insert   Copy the primary selection to the
                  clipboard (same as Copy menu item or ^C)
                  for compatibility with Motif standard key
                  binding
    Shift+Ctrl+
    Insert        Copy the primary selection to the cursor
                  location.
</PRE>
<P>
<PRE>
    Delete        Delete the character before the cursor.
                  (Can be configured to delete the character
                  after the cursor, see "<A HREF="#Customizing_NEdit">Customizing NEdit</A>",
                  and "<A HREF="#X_Resources">X Resources</A>")
</PRE>
<P>
<PRE>
    Ctrl+Delete   Delete to end of line.
</PRE>
<P>
<PRE>
    Shift+Delete  Cut, remove the currently selected text
                  and place it in the clipboard. (same as
                  Cut menu item or ^X) for compatibility
                  with Motif standard key binding
    Shift+Ctrl+
    Delete        Cut the primary selection to the cursor
                  location.
</PRE>
<P>
<PRE>
    Home          Move the cursor to the beginning of the
                  line
</PRE>
<P>
<PRE>
    Ctrl+Home     Move the cursor to the beginning of the
                  file
</PRE>
<P>
<PRE>
    End           Move the cursor to the end of the line
</PRE>
<P>
<PRE>
    Ctrl+End      Move the cursor to the end of the file
</PRE>
<P>
<PRE>
    PageUp        Scroll and move the cursor up by one page.
</PRE>
<P>
<PRE>
    Ctrl+PageUp   Scroll and move the cursor left by one
                  page.
    PageDown      Scroll and move the cursor down by one
                  page.
</PRE>
<P>
<PRE>
    Ctrl+PageDown Scroll and move the cursor right by one
                  page.
</PRE>
<P>
<PRE>
    F10           Make the menu bar active for keyboard
                  input (Arrow Keys, Return, Escape,
                  and the Space Bar)
</PRE>
<P>
<H3>Specialty Keyboards  </H3>
<P>
On machines with different styles of keyboards, generally, text editing
actions are properly matched to the labeled keys, such as Remove,
Next-screen, etc..  If you prefer different key bindings, see the section
titled "<A HREF="#Key_Binding">Key Binding</A>" under the Customizing heading in the Help menu.
<P><HR>
<P>
<A NAME="Shifting_and_Filling"</A>
<H2> Shifting and Filling </H2>
<P>
<H3>Shift Left, Shift Right</H3>
<P>
While shifting blocks of text is most important for programmers (See Features
for Programming), it is also useful for other tasks, such as creating
indented paragraphs.
<P>
To shift a block of text one tab stop to the right, select the text, then
choose Shift Right from the Edit menu.  Note that the accelerator keys for
these menu items are Ctrl+9 and Ctrl+0, which correspond to the right and
left parenthesis on most keyboards.  Remember them as adjusting the text in
the direction pointed to by the parenthesis character.  Holding the Shift key
while selecting either Shift Left or Shift Right will shift the text by one
character.
<P>
It is also possible to shift blocks of text by selecting the text
rectangularly, and dragging it left or right (and up or down as well).  Using
a rectangular selection also causes tabs within the selection to be
recalculated and substituted, such that the non-whitespace characters remain
stationary with respect to the selection.
<P>
<H3>Filling  </H3>
<P>
Text filling using the Fill Paragraph command in the Edit menu is one of the
most important concepts in NEdit.  And it will be well worth your while to
understand how to use it properly.
<P>
In plain text files, unlike word-processor files, there is no way to tell
which lines are continuations of other lines, and which lines are meant to be
separate, because there is no distinction in meaning between newline
characters which separate lines in a paragraph, and ones which separate
paragraphs from other text.  This makes it impossible for a text editor like
NEdit to tell parts of the text which belong together as a paragraph from
carefully arranged individual lines.
<P>
In continuous wrap mode (Preferences -&#62; Wrap -&#62; Continuous), lines
automatically wrap and unwrap themselves to line up properly at the right
margin.  In this mode, you simply omit the newlines within paragraphs and let
NEdit make the line breaks as needed.  Unfortunately, continuous wrap mode is
not appropriate in the majority of situations, because files with extremely
long lines are not common under Unix and may not be compatible with all
tools, and because you can't achieve effects like indented sections, columns,
or program comments, and still take advantage of the automatic wrapping.
<P>
Without continuous wrapping, paragraph filling is not entirely automatic. 
Auto-Newline wrapping keeps paragraphs lined up as you type, but once
entered, NEdit can no longer distinguish newlines which join wrapped text,
and newlines which must be preserved.  Therefore, editing in the middle of a
paragraph will often leave the right margin messy and uneven.
<P>
Since NEdit can't act automatically to keep your text lined up, you need to
tell it explicitly where to operate, and that is what Fill Paragraph is for. 
It arranges lines to fill the space between two margins, wrapping the lines
neatly at word boundaries.  Normally, the left margin for filling is inferred
from the text being filled.  The first line of each paragraph is considered
special, and its left indentation is maintained separately from the remaining
lines (for leading indents, bullet points, numbered paragraphs, etc.). 
Otherwise, the left margin is determined by the furthest left non-whitespace
character.  The right margin is either the Wrap Margin, set in the
preferences menu (by default, the right edge of the window), or can also be
chosen on the fly by using a rectangular selection (see below).
<P>
There are three ways to use Fill Paragraph.  The simplest is, while you are
typing text, and there is no selection, simply select Fill Paragraph (or type
Ctrl+J), and NEdit will arrange the text in the paragraph adjacent to the
cursor.  A paragraph, in this case, means an area of text delimited by blank
lines.
<P>
The second way to use Fill Paragraph is with a selection.  If you select a
range of text and then chose Fill Paragraph, all of the text in the selection
will be filled.  Again, continuous text between blank lines is interpreted as
paragraphs and filled individually, respecting leading indents and blank
lines.
<P>
The third, and most versatile, way to use Fill Paragraph is with a
rectangular selection.  Fill Paragraph treats rectangular selections
differently from other commands.  Instead of simply filling the text inside
the rectangular selection, NEdit interprets the right edge of the selection
as the requested wrap margin.  Text to the left of the selection is not
disturbed (the usual interpretation of a rectangular selection), but text to
the right of the selection is included in the operation and is pulled in to
the selected region.  This method enables you to fill text to an arbitrary
right margin, without going back and forth to the wrap-margin dialog, as well
as to exclude text to the left of the selection such as comment bars or other
text columns.
<P><HR>
<P>
<A NAME="File_Format"</A>
<H2> File Format </H2>
<P>
While plain-text is probably the simplest and most interchangeable file
format in the computer world, there is still variation in what plain-text
means from system to system.  Plain-text files can differ in character set,
line termination, and wrapping.
<P>
While character set differences are the most obvious and pose the most
challenge to portability, they affect NEdit only indirectly via the same font
and localization mechanisms common to all X applications.  If your system is
set up properly, you will probably never see character-set related problems
in NEdit.  NEdit can not display Unicode text files, or any multi-byte
character set.
<P>
The primary difference between an MS DOS format file and a Unix format file,
is how the lines are terminated.  Unix uses a single newline character.  MS
DOS uses a carriage-return and a newline.  NEdit can read and write both file
formats, but internally, it uses the single character Unix standard.  NEdit
auto-detects MS DOS format files based on the line termination at the start
of the file.  Files are judged to be DOS format if all of the first five line
terminators, within a maximum range, are DOS-style.  To change the format in
which NEdit writes a file from DOS to Unix or visa versa, use the Save As...
command and check or un-check the MS DOS Format button.
<P>
Wrapping within text files can vary among individual users, as well as from
system to system.  Both Windows and MacOS make frequent use of plain text
files with no implicit right margin.  In these files, wrapping is determined
by the tool which displays them.  Files of this style also exist on Unix
systems, despite the fact that they are not supported by all Unix utilities. 
To display this kind of file properly in NEdit, you have to select the wrap
style called Continuous.  Wrapping modes are discussed in the sections:
Customizing -&#62; Preferences, and Basic Operation -&#62; Shifting and Filling.
<P>
The last and most minute of format differences is the terminating newline. 
Some Unix compilers and utilities require a final terminating newline on all
files they read and fail in various ways on files which do not have it.  Vi
and approximately half of Unix editors enforce the terminating newline on all
files that they write; Emacs does not enforce this rule.  Users are divided
on which is best.  NEdit makes the final terminating newline optional
(Preferences -&#62; Default Settings -&#62; Append Line Feed on Save).
<P><HR>
<P>
<A NAME="Features_for_Programming"</A>
<H1> Features for Programming </H1>
<P>
<A NAME="Programming_with_NEdit"</A>
<H2> Programming with NEdit </H2>
<P>
Though general in appearance, NEdit has many features intended specifically
for programmers.  Major programming-related topics are listed in separate
sections under the heading: "Features for Programming": <A HREF="#Syntax_Highlighting">Syntax Highlighting</A>,
<A HREF="#Tabs/Emulated_Tabs">Tabs/Emulated Tabs</A>, <A HREF="#Finding_Declarations_(ctags)">Finding Declarations (ctags)</A>, <A HREF="#Calltips">Calltips</A>, and 
<A HREF="#Auto/Smart_Indent">Auto/Smart Indent</A>.  Minor topics related to programming are discussed below:
<P>
<H3>Language Modes</H3>
<P>
When NEdit initially reads a file, it attempts to determine whether the file
is in one of the computer languages that it knows about.  Knowing what language
a file is written in allows NEdit to assign highlight patterns and smart indent
macros, and to set language specific preferences like word delimiters, tab
emulation, and auto-indent.  Language mode can be recognized from both the file
name and from the first 200 characters of content.  Language mode recognition
and language-specific preferences are configured in: Preferences -&#62; Default
Settings -&#62; Language Modes....
<P>
You can set the language mode manually for a window, by selecting it from the
menu: Preferences -&#62; Language Modes.
<P>
<H3>Backlighting</H3>
<P>
Nedit can be made to set the background color of particular classes of
characters to allow easy identifcation of those characters. This is
particularly useful if you need to be able to distiguish between tabs
and spaces in a file where the difference is important. The colors used
for backlighting are specified by a resource, "nedit*backlightCharTypes"
but can be changed for a particular window using the macro built-in function
set_backlight_string(). You can turn backlighting on and off through the
Preferences -&#62; Apply Backlighting menu entry.
<P>
If you prefer to have backlighting turned on for all new windows, use
the Preferences -&#62; Default Settings -&#62; Backlighting -&#62; Apply Backlighting
menu entry. If you wish to set the current window's backlighting settings
for new windows, use Preferences -&#62; Default Settings -&#62; Backlighting -&#62;
Use Current. These settings will be saved along with other preferences
using Preferences -&#62; Save Defaults.
<P>
<H3>Line Numbers</H3>
<P>
To find a particular line in a source file by line number, choose Goto Line
#... from the Search menu.  You can also directly select the line number text
in the compiler message in the terminal emulator window (xterm, decterm,
winterm, etc.) where you ran the compiler, and choose Goto Selected from the
Search menu.
<P>
To find out the line number of a particular line in your file, turn on
Statistics Line in the Preferences menu and position the insertion point
anywhere on the line.  The statistics line continuously updates the line number
of the line containing the cursor.
<P>
To go to a specific column on a given line, choose Goto Line #... from the
Search menu and enter a line number and a column number separated by a 
comma.  (e.g. Enter "100,12" for line 100 column 12.)  If you want to go to
a column on the current line just leave out the line number.  (e.g. Enter
",45" to go the column 45 on the current line.)
<P>
<H3>Matching Parentheses</H3>
<P>
To help you inspect nested parentheses, brackets, braces, quotes, and other
characters, NEdit has both an automatic parenthesis matching mode, and a Goto
Matching command.  Automatic parenthesis matching is activated when you type,
or move the insertion cursor after a parenthesis, bracket, or brace.  It
momentarily highlights either the opposite character ('Delimiter') or the
entire expression ('Range') when the opposite character is visible in the
window. To find a matching character anywhere in the file, select it or
position the cursor after it, and choose Goto Matching from the Search menu. 
If the character matches itself, such as a quote or slash, select the first
character of the pair.  NEdit will match {, (, [, &#60;, ", ', `, /, and \.
Holding the Shift key while typing the accelerator key (Shift+Ctrl+M, by
default), will select all of the text between the matching characters.
<P>
When syntax highlighting is enabled, the matching routines can optionally
make use of the syntax information for improved accuracy. In that case,
a brace inside a highlighted string will not match a brace inside a comment,
for instance.
<P>
<H3>Opening Included Files</H3>
<P>
The Open Selected command in the File menu understands the C preprocessor's
#include syntax, so selecting an #include line and invoking Open Selected will
generally find the file referred to, unless doing so depends on the settings of
compiler switches or other information not available to NEdit.
<P>
<H3>Interface to Programming Tools</H3>
<P>
Integrated software development environments such as SGI's CaseVision and
Centerline Software's Code Center, can be interfaced directly with NEdit via
the client server interface.  These tools allow you to click directly on
compiler and runtime error messages and request NEdit to open files, and select
lines of interest.  The easiest method is usually to use the tool's interface
for character-based editors like vi, to invoke nc, but programmatic interfaces
can also be derived using the source code for nc.
<P>
There are also some simple compile/review, grep, ctree, and ctags browsers
available in the NEdit contrib directory on ftp.nedit.org.
<P><HR>
<P>
<A NAME="Tabs/Emulated_Tabs"</A>
<H2> Tabs/Emulated Tabs </H2>
<P>
<H3>Changing the Tab Distance</H3>
<P>
Tabs are important for programming in languages which use indentation to show
nesting, as short-hand for producing white-space for leading indents.  As a
programmer, you have to decide how to use indentation, and how or whether tab
characters map to your indentation scheme.
<P>
Ideally, tab characters map directly to the amount of indent that you use to
distinguish nesting levels in your code.  Unfortunately, the Unix standard
for interpretation of tab characters is eight characters (probably dating
back to mechanical capabilities of the original teletype), which is usually
too coarse for a single indent.
<P>
Most text editors, NEdit included, allow you to change the interpretation of
the tab character, and many programmers take advantage of this, and set their
tabs to 3 or 4 characters to match their programming style.  In NEdit you set
the hardware tab distance in Preferences -&#62; Tabs... for the current window,
or Preferences -&#62; Default Settings -&#62; Tabs... (general), or Preferences -&#62;
Default Settings -&#62; Language Modes... (language-specific) to change the
defaults for future windows.
<P>
Changing the meaning of the tab character makes programming much easier while
you're in the editor, but can cause you headaches outside of the editor,
because there is no way to pass along the tab setting as part of a plain-text
file.  All of the other tools which display, print, and otherwise process
your source code have to be made aware of how the tabs are set, and must be
able to handle the change.  Non-standard tabs can also confuse other
programmers, or make editing your code difficult for them if their text
editors don't support changes in tab distance.
<P>
<H3>Emulated Tabs</H3>
<P>
An alternative to changing the interpretation of the tab character is tab
emulation.  In the Tabs... dialog(s), turning on Emulated Tabs causes the Tab
key to insert the correct number of spaces and/or tabs to bring the cursor
the next emulated tab stop, as if tabs were set at the emulated tab distance
rather than the hardware tab distance. Backspacing immediately after entering
an emulated tab will delete the fictitious tab as a unit, but as soon as you
move the cursor away from the spot, NEdit will forget that the collection of
spaces and tabs is a tab, and will treat it as separate characters.  To enter
a real tab character with "Emulate Tabs" turned on, use Ctrl+Tab.
<P>
It is also possible to tell NEdit not to insert ANY tab characters at all in
the course of processing emulated tabs, and in shifting and rectangular
insertion/deletion operations, for programmers who worry about the
misinterpretation of tab characters on other systems.
<P><HR>
<P>
<A NAME="Auto/Smart_Indent"</A>
<H2> Auto/Smart Indent </H2>
<P>
Programmers who use structured languages usually require some form of
automatic indent, so that they don't have to continually re-type the
sequences of tabs and/or spaces needed to maintain lengthy running indents. 
Version 5.0 of NEdit is the first release of NEdit to offer "smart" indent,
at least experimentally, in addition to the traditional automatic indent
which simply lines up the cursor position with the previous line.
<P>
<H3>Smart Indent</H3>
<P>
Smart Indent in this release must still be considered somewhat experimental. 
Smart indent macros are only available by default for C and C++, and while
these can easily be configured for different default indentation distances,
they may not conform to everyone's exact C programming style.  Smart indent
is programmed in terms of macros in the NEdit macro language which can be
entered in: Preferences -&#62; Default Settings -&#62; Indent -&#62; Program Smart
Indent.  Hooks are provided for intervening at the point that a newline is
entered, either via the user pressing the Enter key, or through
auto-wrapping; and for arbitrary type-in to act on specific characters typed.
<P>
To type a newline character without invoking smart-indent when operating in
smart-indent mode, hold the Shift key while pressing the Return or Enter key.
<P>
<H3>Auto-Indent</H3>
<P>
With Indent set to Auto (the default), NEdit keeps a running indent.  When
you press the Return or Enter key, spaces and tabs are inserted to line up
the insert point under the start of the previous line.
<P>
Regardless of indent-mode, Ctrl+Return always does the automatic indent;
Shift+Return always does a return without indent.
<P>
<H3>Block Indentation Adjustment</H3>
<P>
The Shift Left and Shift Right commands as well as rectangular dragging can
be used to adjust the indentation for several lines at once.  To shift a
block of text one character to the right, select the text, then choose Shift
Right from the Edit menu.  Note that the accelerator keys for these menu
items are Ctrl+9 and Ctrl+0, which correspond to  the right and left
parenthesis on most keyboards.  Remember them as adjusting the text in the
direction pointed to by the parenthesis character.  Holding the Shift key
while selecting either Shift Left or Shift Right will shift the text by one
tab stop (or by one emulated tab stop if tab emulation is turned on).  The
help section "Shifting and Filling" under "Basic Operation" has details.
<P><HR>
<P>
<A NAME="Syntax_Highlighting"</A>
<H2> Syntax Highlighting </H2>
<P>
Syntax Highlighting means using colors and fonts to help distinguish language
elements in programming languages and other types of structured files. 
Programmers use syntax highlighting to understand code faster and better, and
to spot many kinds of syntax errors more quickly.
<P>
To use syntax highlighting in NEdit, select Highlight Syntax in the
Preferences menu.  If NEdit recognizes the computer language that you are
using, and highlighting rules (patterns) are available for that language, it
will highlight your text, and maintain the highlighting, automatically, as
you type.
<P>
If NEdit doesn't correctly recognize the type of the file you are editing,
you can manually select a language mode from Language Modes in the
Preferences menu.  You can also program the method that NEdit uses to
recognize language modes in Preferences -&#62; Default Settings -&#62; Language
Modes....
<P>
If no highlighting patterns are available for the language that you want to
use, you can create new patterns relatively quickly.  The Help section
"<A HREF="#Highlighting_Patterns">Highlighting Patterns</A>" under "Customizing", has details.
<P>
If you are satisfied with what NEdit is highlighting, but would like it to
use different colors or fonts, you can change these by selecting Preferences
-&#62; Default Settings -&#62; Syntax Highlighting -&#62; Text Drawing Styles. 
Highlighting patterns are connected with font and color information through a
common set of styles so that colorings defined for one language will be
similar across others, and patterns within the same language which are meant
to appear identical can be changed in the same place.  To understand which
styles are used to highlight the language you are interested in, you may need
to look at "<A HREF="#Highlighting_Patterns">Highlighting Patterns</A>" section, as well.
<P>
Syntax highlighting is CPU intensive, and under some circumstances can affect
NEdit's responsiveness.  If you have a particularly slow system, or work with
very large files, you may not want to use it all of the time.  Syntax
highlighting introduces two kinds of delays.  The first is an initial parsing
delay, proportional to the size of the file.  This delay is also incurred
when pasting large sections of text, filtering text through shell commands,
and other circumstances involving changes to large amounts of text.  The
second kind of delay happens when text which has not previously been visible
is scrolled in to view.  Depending on your system, and the highlight patterns
you are using, this may or may not be noticeable.  A typing delay is also
possible, but unlikely if you are only using the built-in patterns.
<P><HR>
<P>
<A NAME="Finding_Declarations_(ctags)"</A>
<H2> Finding Declarations (ctags) </H2>
<P>
<A NAME="ctags"</A>
NEdit can process tags files generated using the Unix ctags command or the
Exuberant Ctags program.  Ctags creates index files correlating names of
functions and declarations with their locations in C, Fortran, or Pascal source
code files. (See the ctags manual page for more information).  Ctags produces a
file called "tags" which can be loaded by NEdit.  NEdit can manage any number
of tags files simultaneously.  Tag collisions are handled with a popup menu to
let the user decide which tag to use.  In 'Smart' mode NEdit will automatically
choose the desired tag based on the scope of the file or module. Once loaded,
the information in the tags file enables NEdit to go directly to the
declaration of a highlighted function or data structure name with a single
command.  To load a tags file, select "Load Tags File" from the File menu and
choose a tags file to load, or specify the name of the tags file on the NEdit
command line:
<P>
<PRE>
      nedit -tags tags
</PRE>
<P>
NEdit can also be set to load a tags file automatically when it starts up. 
Setting the X resource nedit.tagFile to the name of a tag file tells NEdit to
look for that file at startup time (see "<A HREF="#Customizing_NEdit">Customizing NEdit</A>").  The file name
can be either a complete path name, in which case NEdit will always load the
same tags file, or a file name without a path or with a relative path, in
which case NEdit will load it starting from the current directory.  The
second option allows you to have different tags files for different projects,
each automatically loaded depending on the directory you're in when you start
NEdit.  Setting the name to "tags" is an obvious choice since this is the
name that ctags uses. NEdit normally evaluates relative path tag file
specifications every time a file is opened. All accessible tag files are
loaded at this time. To disable the automatic loading of tag files specified
as relative paths, set the X resource nedit.alwaysCheckRelativeTagsSpecs to
False.
<P>
To unload a tags file, select "Un-load Tags File" from the File menu and
choose from the list of tags files.  NEdit will keep track of tags file updates
by checking the timestamp on the files, and automatically update the tags
cache. 
<P>
To find the definition of a function or data structure once a tags file is
loaded, select the name anywhere it appears in your program (see 
"<A HREF="#Selecting_Text">Selecting Text</A>") and choose "Find Definition" from the Search menu.
<P><HR>
<P>
<A NAME="Calltips"</A>
<H2> Calltips </H2>
<P>
Calltips are little yellow boxes that pop up to remind you what the arguments
and return type of a function are.  More generally, they're a UI mechanism to
present a small amount of crucial information in a prominent location.  To 
display a calltip, select some text and choose "Show Calltip" from the Search
menu.  To kill a displayed calltip, hit Esc.
<P>
Calltips get their information from one of two places -- either a tags file (see
"<A HREF="#Finding_Declarations_(ctags)">Finding Declarations (ctags)</A>") or a calltips file.  First, any loaded calltips 
files are searched for a definition, and if nothing is found then the tags 
database is searched.  If a tag is found that matches the hilighted text then
a calltip is displayed with the first few lines of the definition -- usually 
enough to show you what the arguments of a function are.
<P>
You can load a calltips file by using choosing "Load Calltips File" from the
File menu.  You can unload a calltips file by selecting it from the 
"Unload Calltips File" submenu of the File menu.  You can also choose one or
more default calltips files to be loaded for each language mode using the 
"Default calltips file(s)" field of the Language Modes dialog.
<P>
The calltips file format is very simple.  calltips files are organized in blocks
separated by blank lines.  The first line of the block is the key, which is the
word that is matched when a calltip is requested.  The rest of the block is
displayed as the calltip.  
<P>
Almost any text at all can appear in a calltip key or a calltip.  There are no
special characters that need to be escaped.  The only issues to note are that
trailing whitespace is ignored, and you cannot have a blank line inside a
calltip.  (Use a single period instead --  it'll be nearly invisible.)  You should
also avoid calltip keys that begin and end with '*' characters, since those are
used to mark special blocks.
<P>
There are five special block types--comment, include, language, alias, and 
version--which are distinguished by their first lines, "* comment *", 
"* include *", "* language *", "* alias *", and "* version *" respectively 
(without quotes).
<P>
Comment blocks are ignored when reading calltips files.
<P>
Include blocks specify additional calltips files to load, one per line.  The ~
character can be used for your $HOME directory, but other shell shortcuts like
* and ? can't be used. Include blocks allow you to make a calltips file for your
project that includes, say, the calltips files for C, Motif, and Xt.
<P>
Language blocks specify which language mode the calltips should be used with. 
When a calltip is requested it won't match tips from languages other than the
current language mode.  Language blocks only affect the tips listed after the
block.
<P>
Alias blocks allow a calltip to have multiple keys.  The first line of the block
is the key for the calltip to be displayed, and the rest of the lines are
additional keys, one per line, that should also show the calltip.
<P>
Version blocks are ignored for the time being.
<P>
You can use calltips in your own macros using the calltip() and kill_calltip()
macro subroutines and the $calltip_ID macro variable.  See the 
<A HREF="#Macro_Subroutines">Macro Subroutines</A> section for details.
<P><HR>
<P>
<A NAME="Regular_Expressions"</A>
<H1> Regular Expressions </H1>
<P>
<A NAME="Basic_Regular_Expression_Syntax"</A>
<H2> Basic Regular Expression Syntax </H2>
<P>
Regular expressions (regex's) are useful as a way to match inexact sequences
of characters.  They can be used in the `Find...' and `Replace...' search
dialogs and are at the core of Color Syntax Highlighting patterns.  To specify
a regular expression in a search dialog, simply click on the `Regular
Expression' radio button in the dialog.
<P>
A regex is a specification of a pattern to be matched in the searched text. 
This pattern consists of a sequence of tokens, each being able to match a
single character or a sequence of characters in the text, or assert that a
specific position within the text has been reached (the latter is called an
anchor.)  Tokens (also called atoms) can be modified by adding one of a number
of special quantifier tokens immediately after the token.  A quantifier token
specifies how many times the previous token must be matched (see below.)
<P>
Tokens can be grouped together using one of a number of grouping constructs,
the most common being plain parentheses.  Tokens that are grouped in this way
are also collectively considered to be a regex atom, since this new larger
atom may also be modified by a quantifier.
<P>
A regex can also be organized into a list of alternatives by separating each
alternative with pipe characters, `|'.  This is called alternation.  A match
will be attempted for each alternative listed, in the order specified, until a
match results or the list of alternatives is exhausted (see <A HREF="#alternation">Alternation</A>
section below.)
<P>
<H3>The 'Any' Character</H3>
<P>
If a dot (`.') appears in a regex, it means to match any character exactly
once.  By default, dot will not match a newline character, but this behavior
can be changed (see help topic <A HREF="#Parenthetical_Constructs">Parenthetical Constructs</A>, under the
heading, Matching Newlines).
<P>
<H3>Character Classes</H3>
<P>
A character class, or range, matches exactly one character of text, but the
candidates for matching are limited to those specified by the class.  Classes
come in two flavors as described below:
<P>
<PRE>
     [...]   Regular class, match only characters listed.
     [^...]  Negated class, match only characters NOT listed.
</PRE>
<P>
As with the dot token, by default negated character classes do not match
newline, but can be made to do so.
<P>
The characters that are considered special within a class specification are
different than the rest of regex syntax as follows. If the first character in
a class is the `]' character (second character if the first character is `^')
it is a literal character and part of the class character set.  This also
applies if the first or last character is `-'.  Outside of these rules, two
characters separated by `-' form a character range which includes all the
characters between the two characters as well.  For example, `[^f-j]' is the
same as `[^fghij]' and means to match any character that is not `f', `g',
`h', `i', or `j'.
<P>
<H3>Anchors</H3>
<P>
Anchors are assertions that you are at a very specific position within the
search text.  NEdit regular expressions support the following anchor tokens:
<P>
<PRE>
     ^    Beginning of line
     $    End of line
     &#60;    Left word boundary
     &#62;    Right word boundary
     \B   Not a word boundary
</PRE>
<P>
Note that the \B token ensures that the left and right characters are both
delimiter characters, or that both left and right characters are
non-delimiter characters.  Currently word anchors check only one character,
e.g. the left word anchor `&#60;' only asserts that the left character is a word
delimiter character.  Similarly the right word anchor checks the right
character.
<P>
<H3>Quantifiers</H3>
<P>
Quantifiers specify how many times the previous regular expression atom may
be matched in the search text.  Some quantifiers can produce a large
performance penalty, and can in some instances completely lock up NEdit.  To
prevent this, avoid nested quantifiers, especially those of the maximal
matching type (see below.)
<P>
The following quantifiers are maximal matching, or "greedy", in that they
match as much text as possible.
<P>
<PRE>
     *   Match zero or more
     +   Match one  or more
     ?   Match zero or one
</PRE>
<P>
The following quantifiers are minimal matching, or "lazy", in that they match
as little text as possible.
<P>
<PRE>
     *?   Match zero or more
     +?   Match one  or more
     ??   Match zero or one
</PRE>
<P>
One final quantifier is the counting quantifier, or brace quantifier. It
takes the following basic form:
<P>
<PRE>
     {min,max}  Match from `min' to `max' times the
                previous regular expression atom.
</PRE>
<P>
If `min' is omitted, it is assumed to be zero.  If `max' is omitted, it is
assumed to be infinity.  Whether specified or assumed, `min' must be less
than or equal to `max'.  Note that both `min' and `max' are limited to
65535.  If both are omitted, then the construct is the same as `*'.   Note
that `{,}' and `{}' are both valid brace constructs.  A single number
appearing without a comma, e.g. `{3}' is short for the `{min,min}' construct,
or to match exactly `min' number of times.
<P>
The quantifiers `{1}' and `{1,1}' are accepted by the syntax, but are
optimized away since they mean to match exactly once, which is redundant
information.  Also, for efficiency, certain combinations of `min' and `max'
are converted to either `*', `+', or `?' as follows:
<P>
<PRE>
     {} {,} {0,}    *
     {1,}           +
     {,1} {0,1}     ?
</PRE>
<P>
Note that {0} and {0,0} are meaningless and will generate an error message at
regular expression compile time.
<P>
Brace quantifiers can also be "lazy".  For example {2,5}? would try to match
2 times if possible, and will only match 3, 4, or 5 times if that is what is
necessary to achieve an overall match.
<P>
<H3>Alternation</H3>
<P>
A series of alternative patterns to match can be specified by separating them
<A NAME="alternation"</A>
with vertical pipes, `|'.  An example of alternation would be `a|be|sea'. 
This will match `a', or `be', or `sea'. Each alternative can be an
arbitrarily complex regular expression. The alternatives are attempted in
the order specified.  An empty alternative can be specified if desired, e.g.
`a|b|'.  Since an empty alternative can match nothingness (the empty string),
this guarantees that the expression will match.
<P>
<H3>Comments</H3>
<P>
Comments are of the form `(?#&#60;comment text&#62;)' and can be inserted anywhere
and have no effect on the execution of the regular expression.  They can be
handy for documenting very complex regular expressions.  Note that a comment
begins with `(?#' and ends at the first occurrence of an ending parenthesis,
or the end of the regular expression... period.  Comments do not recognize
any escape sequences.
<P><HR>
<P>
<A NAME="Metacharacters"</A>
<H2> Metacharacters </H2>
<P>
<H3>Escaping Metacharacters</H3>
<P>
In a regular expression (regex), most ordinary characters match themselves.  
For example, `ab%' would match anywhere `a' followed by `b' followed by `%'
appeared in the text.  Other characters don't match themselves, but are
metacharacters. For example, backslash is a special metacharacter which
'escapes' or changes the meaning of the character following it. Thus, to
match a literal backslash would require a regular expression to have two
backslashes in sequence. NEdit provides the following escape sequences so
that metacharacters that are used by the regex syntax can be specified as
ordinary characters.
<P>
<PRE>
     \(  \)  \-  \[  \]  \&#60;  \&#62;  \{  \}
     \.  \|  \^  \$  \*  \+  \?  \&#38;  \\
</PRE>
<P>
<H3>Special Control Characters</H3>
<P>
There are some special characters that are  difficult or impossible to type. 
Many of these characters can be constructed as a sort of metacharacter or
sequence by preceding a literal character with a backslash. NEdit recognizes
the following special character sequences:
<P>
<PRE>
     \a  alert (bell)
     \b  backspace
     \e  ASCII escape character (***)
     \f  form feed (new page)
     \n  newline
     \r  carriage return
     \t  horizontal tab
     \v  vertical tab
</PRE>
<P>
<PRE>
     *** For environments that use the EBCDIC character set,
         when compiling NEdit set the EBCDIC_CHARSET compiler
         symbol to get the EBCDIC equivalent escape
         character.)
</PRE>
<P>
<H3>Octal and Hex Escape Sequences</H3>
<P>
Any ASCII (or EBCDIC) character, except null, can be specified by using
either an octal escape or a hexadecimal escape, each beginning with \0 or \x
(or \X), respectively.  For example, \052 and \X2A both specify the `*'
character.  Escapes for null (\00 or \x0) are not valid and will generate an
error message.  Also, any escape that exceeds \0377 or \xFF will either cause
an error or have any additional character(s) interpreted literally. For
example, \0777 will be interpreted as \077 (a `?' character) followed by `7'
since \0777 is greater than \0377.
<P>
An invalid digit will also end an octal or hexadecimal escape.  For example,
\091 will cause an error since `9' is not within an octal escape's range of
allowable digits (0-7) and truncation before the `9' yields \0 which is
invalid.
<P>
<H3>Shortcut Escape Sequences</H3>
<P>
NEdit defines some escape sequences that are handy shortcuts for commonly
used character classes.
<P>
<PRE>
   \d  digits            0-9
   \l  letters           a-z, A-Z, and locale dependent letters
   \s  whitespace        \t, \r, \v, \f, and space
   \w  word characters   letters, digits, and underscore, `_'
</PRE>
<P>
\D, \L, \S, and \W are the same as the lowercase versions except that the
resulting character class is negated.  For example, \d is equivalent to
`[0-9]', while \D is equivalent to `[^0-9]'.
<P>
These escape sequences can also be used within a character class.  For
example, `[\l_]' is the same as `[a-zA-Z_]', extended with possible locale 
dependent letters. The escape sequences for special characters, and octal
and hexadecimal escapes are also valid within a class.
<P>
<H3>Word Delimiter Tokens</H3>
<P>
Although not strictly a character class, the following escape sequences
behave similarly to character classes:
<P>
<PRE>
     \y   Word delimiter character
     \Y   Not a word delimiter character
</PRE>
<P>
The `\y' token matches any single character that is one of the characters
that NEdit recognizes as a word delimiter character, while the `\Y' token
matches any character that is NOT a word delimiter character.  Word delimiter
characters are dynamic in nature, meaning that the user can change them through
preference settings.  For this reason, they must be handled differently by the
regular expression engine.  As a consequence of this, `\y' and `\Y' can not be
used within a character class specification.
<P><HR>
<P>
<A NAME="Parenthetical_Constructs"</A>
<H2> Parenthetical Constructs </H2>
<P>
<H3>Capturing Parentheses</H3>
<P>
Capturing Parentheses are of the form `(&#60;regex&#62;)' and can be used to group
arbitrarily complex regular expressions.  Parentheses can be nested, but the
total number of parentheses, nested or otherwise, is limited to 50 pairs. 
The text that is matched by the regular expression between a matched set of
parentheses is captured and available for text substitutions and
backreferences (see below.)  Capturing parentheses carry a fairly high
overhead both in terms of memory used and execution speed, especially if
quantified by `*' or `+'.
<P>
<H3>Non-Capturing Parentheses</H3>
<P>
Non-Capturing Parentheses are of the form `(?:&#60;regex&#62;)' and facilitate
grouping only and do not incur the overhead of normal capturing parentheses. 
They should not be counted when determining numbers for capturing parentheses
which are used with backreferences and substitutions.  Because of the limit
on the number of capturing parentheses allowed in a regex, it is advisable to
use non-capturing parentheses when possible.
<P>
<H3>Positive Look-Ahead</H3>
<P>
Positive look-ahead constructs are of the form `(?=&#60;regex&#62;)' and implement a
zero width assertion of the enclosed regular expression.  In other words, a
match of the regular expression contained in the positive look-ahead
construct is attempted.  If it succeeds, control is passed to the next
regular expression atom, but the text that was consumed by the positive
look-ahead is first unmatched (backtracked) to the place in the text where
the positive look-ahead was first encountered.
<P>
One application of positive look-ahead is the manual implementation of a
first character discrimination optimization.  You can include a positive
look-ahead that contains a character class which lists every character that
the following (potentially complex) regular expression could possibly start
with.  This will quickly filter out match attempts that can not possibly
succeed.
<P>
<H3>Negative Look-Ahead</H3>
<P>
Negative look-ahead takes the form `(?!&#60;regex&#62;)' and is exactly the same as
positive look-ahead except that the enclosed regular expression must NOT
match.  This can be particularly useful when you have an expression that is
general, and you want to exclude some special cases.  Simply precede the
general expression with a negative look-ahead that covers the special cases
that need to be filtered out.
<P>
<H3>Positive Look-Behind</H3>
<P>
Positive look-behind constructs are of the form `(?&#60;=&#60;regex&#62;)' and implement
a zero width assertion of the enclosed regular expression in front of the
current matching position.  It is similar to a positive look-ahead assertion,
except for the fact the the match is attempted on the text preceeding the
current position, possibly even in front of the start of the matching range
of the entire regular expression.
<P>
A restriction on look-behind expressions is the fact that the expression
must match a string of a bounded size.  In other words, `*', `+', and `{n,}'
quantifiers are not allowed inside the look-behind expression. Moreover,
matching performance is sensitive to the difference between the upper and
lower bound on the matching size.  The smaller the difference, the better the
performance.  This is especially important for regular expressions used in
highlight patterns.
<P>
Another (minor) restriction is the fact that look-<B>ahead</B> patterns, nor
any construct that requires look-ahead information (such as word boundaries)
are supported at the end of a look-behind pattern (no error is raised, but
matching behaviour is unspecified). It is always possible to place these
look-ahead patterns immediately after the look-behind pattern, where they
will work as expected.
<P>
Positive look-behind has similar applications as positive look-ahead.
<P>
<H3>Negative Look-Behind</H3>
<P>
Negative look-behind takes the form `(?&#60;!&#60;regex&#62;)' and is exactly the same as
positive look-behind except that the enclosed regular expression must
NOT match. The same restrictions apply.
<P>
Note however, that performance is even more sensitive to the distance 
between the size boundaries: a negative look-behind must not match for 
<B>any</B> possible size, so the matching engine must check <B>every</B> size.
<P>
<H3>Case Sensitivity</H3>
<P>
There are two parenthetical constructs that control case sensitivity:
<P>
<PRE>
     (?i&#60;regex&#62;)   Case insensitive; `AbcD' and `aBCd' are
                   equivalent.
</PRE>
<P>
<PRE>
     (?I&#60;regex&#62;)   Case sensitive;   `AbcD' and `aBCd' are
                   different.
</PRE>
<P>
Regular expressions are case sensitive by default, that is, `(?I&#60;regex&#62;)' is
assumed.  All regular expression token types respond appropriately to case
insensitivity including character classes and backreferences.  There is some
extra overhead involved when case insensitivity is in effect, but only to the
extent of converting each character compared to lower case.
<P>
<H3>Matching Newlines</H3>
<P>
NEdit regular expressions by default handle the matching of newlines in a way
that should seem natural for most editing tasks.  There are situations,
however, that require finer control over how newlines are matched by some
regular expression tokens.
<P>
By default, NEdit regular expressions will NOT match a newline character for
the following regex tokens: dot (`.'); a negated character class (`[^...]');
and the following shortcuts for character classes:
<P>
<PRE>
     `\d', `\D', `\l', `\L', `\s', `\S', `\w', `\W', `\Y'
</PRE>
<P>
The matching of newlines can be controlled for the `.' token, negated
character classes, and the `\s' and `\S' shortcuts by using one of the
following parenthetical constructs:
<P>
<PRE>
     (?n&#60;regex&#62;)  `.', `[^...]', `\s', `\S' match newlines
</PRE>
<P>
<PRE>
     (?N&#60;regex&#62;)  `.', `[^...]', `\s', `\S' don't match
                                            newlines
</PRE>
<P>
`(?N&#60;regex&#62;)' is the default behavior.
<P>
<H3>Notes on New Parenthetical Constructs</H3>
<P>
Except for plain parentheses, none of the parenthetical constructs capture
text.  If that is desired, the construct must be wrapped with capturing
parentheses, e.g. `((?i&#60;regex))'.
<P>
All parenthetical constructs can be nested as deeply as desired, except for
capturing parentheses which have a limit of 50 sets of parentheses,
regardless of nesting level.
<P>
<H3>Back References</H3>
<P>
Backreferences allow you to match text captured by a set of capturing
parenthesis at some later position in your regular expression.  A
backreference is specified using a single backslash followed by a single
digit from 1 to 9 (example: \3).  Backreferences have similar syntax to
substitutions (see below), but are different from substitutions in that they
appear within the regular expression, not the substitution string. The number
specified with a backreference identifies which set of text capturing
parentheses the backreference is associated with. The text that was most
recently captured by these parentheses is used by the backreference to
attempt a match.  As with substitutions, open parentheses are counted from
left to right beginning with 1.  So the backreference `\3' will try to match
another occurrence of the text most recently matched by the third set of
capturing parentheses.  As an example, the regular expression `(\d)\1' could
match `22', `33', or `00', but wouldn't match `19' or `01'.
<P>
A backreference must be associated with a parenthetical expression that is
complete.  The expression `(\w(\1))' contains an invalid backreference since
the first set of parentheses are not complete at the point where the
backreference appears.
<P>
<H3>Substitution</H3>
<P>
Substitution strings are used to replace text matched by a set of capturing
parentheses.  The substitution string is mostly interpreted as ordinary text
except as follows.
<P>
The escape sequences described above for special characters, and octal and
hexadecimal escapes are treated the same way by a substitution string. When
the substitution string contains the `&#38;' character, NEdit will substitute the
entire string that was matched by the `Find...' operation. Any of the first
nine sub-expressions of the match string can also be inserted into the
replacement string.  This is done by inserting a `\' followed by a digit from
1 to 9 that represents the string matched by a parenthesized expression
within the regular expression.  These expressions are numbered left-to-right
in order of their opening parentheses.
<P>
The capitalization of text inserted by `&#38;' or `\1', `\2', ... `\9' can be
altered by preceding them with `\U', `\u', `\L', or `\l'.  `\u' and `\l'
change only the first character of the inserted entity, while `\U' and `\L'
change the entire entity to upper or lower case, respectively.
<P><HR>
<P>
<A NAME="Advanced_Topics"</A>
<H2> Advanced Topics </H2>
<P>
<H3>Substitutions</H3>
<P>
Regular expression substitution can be used to program automatic editing
operations.  For example, the following are search and replace strings to find
occurrences of the `C' language subroutine `get_x', reverse the first and
second parameters, add a third parameter of NULL, and change the name to
`new_get_x':
<P>
<PRE>
     Search string:   `get_x *\( *([^ ,]*), *([^\)]*)\)'
     Replace string:  `new_get_x(\2, \1, NULL)'
</PRE>
<P>
<H3>Ambiguity</H3>
<P>
If a regular expression could match two different parts of the text, it will
match the one which begins earliest.  If both begin in the same place but
match different lengths, or match the same length in different ways, life
gets messier, as follows.
<P>
In general, the possibilities in a list of alternatives are considered in
left-to-right order.  The possibilities for `*', `+', and `?' are considered
longest-first, nested constructs are considered from the outermost in, and
concatenated constructs are considered leftmost-first. The match that will be
chosen is the one that uses the earliest possibility in the first choice that
has to be made.  If there is more than one choice, the next will be made in
the same manner (earliest possibility) subject to the decision on the first
choice.  And so forth.
<P>
For example, `(ab|a)b*c' could match `abc' in one of two ways.  The first
choice is between `ab' and `a'; since `ab' is earlier, and does lead to a
successful overall match, it is chosen.  Since the `b' is already spoken for,
the `b*' must match its last possibility, the empty string, since it must
respect the earlier choice.
<P>
In the particular case where no `|'s are present and there is only one `*',
`+', or `?', the net effect is that the longest possible match will be
chosen.  So `ab*', presented with `xabbbby', will match `abbbb'.  Note that
if `ab*' is tried against `xabyabbbz', it will match `ab' just after `x', due
to the begins-earliest rule.  (In effect, the decision on where to start the
match is the first choice to be made, hence subsequent choices must respect
it even if this leads them to less-preferred alternatives.)
<P>
<H3>References</H3>
<P>
An excellent book on the care and feeding of regular expressions is
<P>
<PRE>
          "Mastering Regular Expressions"
          Jeffrey E. F. Friedl
          (c) 1997, O'Reilly &#38; Associates
          ISBN 1-56592-257-3
<P><HR>
</PRE>
<P>
<A NAME="Example_Regular_Expressions"</A>
<H2> Example Regular Expressions </H2>
<P>
The following are regular expression examples which will match:
<P>
<UL>
    <li>An entire line.</li>
</UL>
<PRE>
        ^.*$
 
</PRE>
<UL>
    <li>Blank lines.</li>
</UL>
<PRE>
        ^$
 
</PRE>
<UL>
    <li>Whitespace on a line.</li>
</UL>
<PRE>
        \s+
 
</PRE>
<UL>
    <li>Whitespace across lines.</li>
</UL>
<PRE>
        (?n\s+)
 
</PRE>
<UL>
    <li>Whitespace that spans at least two lines. Note minimal matching `*?' quantifier.</li>
</UL>
<PRE>
        (?n\s*?\n\s*)
 
</PRE>
<UL>
    <li>IP address (not robust).</li>
</UL>
<PRE>
        (?:\d{1,3}(?:\.\d{1,3}){3})
 
</PRE>
<UL>
    <li>Two character US Postal state abbreviations (includes territories).</li>
</UL>
<PRE>
        [ACDF-IK-PR-W][A-Z]
 
</PRE>
<UL>
    <li>Web addresses.</li>
</UL>
<PRE>
        (?:http://)?www\.\S+
 
</PRE>
<UL>
    <li>Case insensitive double words across line breaks.</li>
</UL>
<PRE>
        (?i(?n&#60;(\S+)\s+\1&#62;))
 
</PRE>
<UL>
    <li>Upper case words with possible punctuation.</li>
</UL>
<PRE>
        &#60;[A-Z][^a-z\s]*&#62;
<P><HR>
</PRE>
<P>
<A NAME="Macro/Shell_Extensions"</A>
<H1> Macro/Shell Extensions </H1>
<P>
<A NAME="Shell_Commands_and_Filters"</A>
<H2> Shell Commands and Filters </H2>
<P>
The Shell menu (Unix versions only) allows you to execute Unix shell commands
from within NEdit.  You can add items to the menu to extend NEdit's command
set or to incorporate custom automatic editing features using shell commands
or editing languages like awk and sed.  To add items to the menu, select
Preferences -&#62; Default Settings Customize Menus -&#62; Shell Menu.  NEdit comes
pre-configured with a few useful Unix commands like spell and sort, but we
encourage you to add your own custom extensions.
<P>
Filter Selection... prompts you for a Unix command to use to process the
currently selected text.  The output from this command replaces the contents
of the selection.
<P>
Execute Command... prompts you for a Unix command and replaces the current
selection with the output of the command.  If there is no  selection, it
deposits the output at the current insertion point. In the Shell Command
field, the % character expands to the name (including directory path), and
the # character expands to the current line number of the file in the window.
To include a % or # character in the command, use %% or ##, respectively.  
<P>
Execute Command Line uses the position of the cursor in the window to
indicate a line to execute as a shell command line.  The cursor may be
positioned anywhere on the line.  This command allows you to use an NEdit
window as an editable command window for saving output and saving commands
for re-execution. Note that the same character expansions described above
in Execute Command also occur with this command.
<P>
The X resource called nedit.shell (See "<A HREF="#Customizing_NEdit">Customizing NEdit</A>") determines which
Unix shell is used to execute commands.  The default value for this resource
is /bin/csh.
<P><HR>
<P>
<A NAME="Learn/Replay"</A>
<H2> Learn/Replay </H2>
<P>
Selecting Learn Keystrokes from the Macro menu puts NEdit in learn mode.  In
learn mode, keystrokes and menu commands are recorded, to be played back
later, using the Replay Keystrokes command, or pasted into a macro in the
Macro Commands dialog of the Default Settings menu in Preferences.
<P>
Note that only keyboard and menu commands are recorded, not mouse clicks or
mouse movements since these have no absolute point of reference, such as
cursor or selection position.  When you do a mouse-based operation in learn
mode, NEdit will beep (repeatedly) to remind you that the operation was not
recorded.
<P>
Learn mode is also the quickest and easiest method for writing macros.  The
dialog for creating macro commands contains a button labeled "Paste Learn /
Replay Macro", which will deposit the last sequence learned into the body of
the macro.
<P>
<H3>Repeating Actions and Learn/Replay Sequences</H3>
<P>
You can repeat the last (keyboard-based) command, or learn/replay sequence
with the Repeat... command in the Macro menu.  To repeat an action, first do
the action (that is, insert a character, do a search, move the cursor), then
select Repeat..., decide how or how many times you want it repeated, and
click OK.  For example, to move down 30 lines through a file, you could type:
&#60;Down Arrow&#62; Ctrl+, 29 &#60;Return&#62;.  To repeat a learn/replay sequence, first
learn it, then select Repeat..., click on Learn/Replay and how you want it
repeated, then click OK.
<P>
If the commands you are repeating advance the cursor through the file, you
can also repeat them within a range of characters, or from the current cursor
position to the end of the file.  To iterate over a range of characters, use
the primary selection (drag the left mouse button over the text) to mark the
range you want to operate on, and select "In Selection" in the Repeat dialog.
<P>
When using In "Selection" or "To End" with a learned sequence, try to do
cursor movement as the last step in the sequence, since testing of the cursor
position is only done at the end of the sequence execution.  If you do cursor
movement first, for example searching for a particular word then doing a
modification, the position of the cursor won't be checked until the sequence
has potentially gone far beyond the end of your desired range.
<P>
It's easy for a repeated command to get out of hand, and you can easily
generate an infinite loop by using range iteration on a command which doesn't
progress.  To cancel a repeating command in progress, type Ctrl+. (period),
or select Cancel Macro from the Macro menu.
<P><HR>
<P>
<A NAME="Macro_Language"</A>
<H2> Macro Language </H2>
<P>
Macros can be called from Macro menu commands, window background menu
commands, within the smart-indent framework, from the autoload macro file and
from the command line.
Macro menu and window background menu commands are defined under Preferences
-&#62; Default Settings -&#62; Customize Menus.  Help on creating items in these
menus can be found in the section, Help -&#62; Customizing -&#62; Preferences.
<P>
The autoload macro file is a file of macro commands and definitions which
NEdit will automatically execute when it is first started.  Its location is
dependent on your environment:
<P>
<UL>
    <li>The default place for the file is '$HOME/.nedit/autoload.nm',</li>
    <li>if the variable $NEDIT_HOME is set in your environment it is located at '$NEDIT_HOME/autoload.nm',</li>
    <li>if you are using old-style run control files (i.e. $HOME/.nedit is a regular file) it is located in '$HOME/.neditmacro'.</li>
</UL>
<P>
(For VMS, the file is in '$NEDIT_HOME/autoload.nm' if $NEDIT_HOME is set, in
'SYS$LOGIN:.neditmacro' otherwise.)
<P>
NEdit's macro language is a simple interpreter with integer arithmetic,
dynamic strings, and C-style looping constructs (very similar to the
procedural portion of the Unix awk program).  From the macro language, you
can call the same action routines which are bound to keyboard keys and menu
items, as well additional subroutines for accessing and manipulating editor
data, which are specific to the macro language (these are listed in the
sections titled "<A HREF="#Macro_Subroutines">Macro Subroutines</A>", and "<A HREF="#Action_Routines">Action Routines</A>").
<P>
<H3>Syntax</H3>
<P>
An NEdit macro language program consists of a list of statements, each
terminated by a newline.  Groups of statements which are executed together
conditionally, such as the body of a loop, are surrounded by curly braces
"{}".
<P>
Blank lines and comments are also allowed.  Comments begin with a "#" and end
with a newline, and can appear either on a line by themselves, or at the end
of a statement.
<P>
Statements which are too long to fit on a single line may be split across
several lines, by placing a backslash "\" character at the end of each line
to be continued.
<P>
<H3>Data Types</H3>
<P>
The NEdit macro language recognizes only three data types, dynamic character
strings, integer values and associative arrays. In general strings and
integers can be used interchangeably. If a string represents an integer
value, it can be used as an integer. Integers can be compared and
concatenated with strings. Arrays may contain integers, strings, or arrays.
Arrays are stored key/value pairs. Keys are always stored as strings.
<P>
<H4>Integer Constants</H4>
<P>
Integers are non-fractional numbers in the range of -2147483647 to
2147483647.  Integer constants must be in decimal.  For example:
<P>
<PRE>
    a = -1
    b = 1000
</PRE>
<P>
<H4>Character String Constants</H4>
<P>
Character string constants are enclosed in double quotes.  For example:
<P>
<PRE>
     a = "a string"
     dialog("Hi there!", "Dismiss")
</PRE>
<P>
Strings may also include C-language style escape sequences:
<P>
<PRE>
     \\ Backslash     \t Tab              \f Form feed
     \" Double quote  \b Backspace        \a Alert
     \n Newline       \r Carriage return  \v Vertical tab
</PRE>
<P>
For example, to send output to the terminal from which NEdit was started, a
newline character is necessary because, like printf, t_print requires
explicit newlines, and also buffers its output on a per-line basis:
<P>
<PRE>
     t_print("a = " a "\n")
</PRE>
<P>
<H3>Variables</H3>
<P>
Variable names must begin either with a letter (local variables), or a $
(global variables).  Beyond the first character, variables may also contain
numbers and underscores `_'.  Variables are called in to existence just by
setting them (no explicit declarations are necessary).
<P>
Local variables are limited in scope to the subroutine (or menu item
definition) in which they appear.  Global variables are accessible from all
routines, and their values persist beyond the call which created them, until
reset.
<P>
<H4>Built-in Variables</H4>
<P>
NEdit has a number of permanently defined variables, which are used to access
global editor information and information about the the window in which the
macro is executing.  These are listed along with the built in functions in
the section titled "<A HREF="#Macro_Subroutines">Macro Subroutines</A>".
<P>
<H3>Functions and Subroutines</H3>
<P>
The syntax of a function or subroutine call is:
<P>
<PRE>
     function_name(arg1, arg2, ...)
</PRE>
<P>
where arg1, arg2, etc. represent up to 9 argument values which are passed to
the routine being called.  A function or subroutine call can be on a line by
itself, as above, or if it returns a value, can be invoked within a character
or numeric expression:
<P>
<PRE>
     a = fn1(b, c) + fn2(d)
     dialog("fn3 says: " fn3())
</PRE>
<P>
Arguments are passed by value.  This means that you can not return values via
the argument list, only through the function value or indirectly through
agreed-upon global variables.
<P>
<H4>Built-in Functions</H4>
<P>
NEdit has a wide range of built in functions which can be called from the
macro language.  These routines are divided into two classes, macro-language
functions, and editor action routines.  Editor action routines are more
flexible, in that they may be called either from the macro language, or bound
directly to keys via translation tables.  They are also limited, however, in
that they can not return values.  Macro language routines can return values,
but can not be bound to keys in translation tables.
<P>
Nearly all of the built-in subroutines operate on an implied window, which is
initially the window from which the macro was started.  To manipulate the
contents of other windows, use the focus_window subroutine to change the
focus to the ones you wish to modify.  focus_window can also be used to
iterate over all of the currently open windows, using the special keyword
names, "last" and "next".
<P>
For backwards compatibility, hyphenated action routine names are allowed, and
most of the existing action routines names which contain underscores have an
equivalent version containing hyphens ('-') instead of underscores.  Use of
these names is discouraged.  The macro parser resolves the ambiguity between
'-' as the subtraction/negation operator, and - as part of an action routine
name by assuming subtraction unless the symbol specifically matches an action
routine name.
<P>
<H4>User Defined Functions</H4>
<P>
Users can define their own macro subroutines, using the define keyword:
<P>
<PRE>
     define subroutine_name {
        &#60; body of subroutine &#62;
     }
</PRE>
<P>
Macro definitions can not appear within other definitions, or within macro
menu item definitions (usually they are found in the autoload macro file).
<P>
The arguments with which a user-defined subroutine or function was invoked,
are presented as $1, $2, ... , $9.  The number of arguments can be read from
$n_args.
<P>
To return a value from a subroutine, and/or to exit from the subroutine
before the end of the subroutine body, use the return statement:
<P>
<PRE>
     return &#60;value to return&#62;
</PRE>
<P>
<H3>Operators and Expressions</H3>
<P>
Operators have the same meaning and precedence that they do in C, except for
^, which raises a number to a power (y^x means y to the x power), rather than
bitwise exclusive OR.  The table below lists operators in decreasing order of
precedence.
<P>
<PRE>
     Operators                Associativity
     ()
     ^                        right to left
     - ! ++ --                (unary)
     * / %                    left to right
     + -                      left to right
     &#62; &#62;= &#60; &#60;= == !=          left to right
     &#38;                        left to right
     |                        left to right
     &#38;&#38;                       left to right
     ||                       left to right
     (concatenation)          left to right
     = += -= *= /= %=, &#38;= |=  right to left
</PRE>
<P>
The order in which operands are evaluated in an expression is undefined,
except for &#38;&#38; and ||, which like C, evaluate operands left to right, but stop
when further evaluation would no longer change the result.
<P>
<H4>Numerical Operators</H4>
<P>
The numeric operators supported by the NEdit macro language are listed below:
<P>
<PRE>
     + addition
     - subtraction or negation
     * multiplication
     / division
     % modulo
     ^ power
     &#38; bitwise and
     | bitwise or
</PRE>
<P>
Increment (++) and decrement (--) operators can also be appended or prepended
to variables within an expression.  Prepended increment/decrement operators
act before the variable is evaluated.  Appended increment/decrement operators
act after the variable is evaluated.
<P>
<H4>Logical and Comparison Operators</H4>
<P>
Logical operations produce a result of 0 (for false) or 1 (for true).  In a
logical operation, any non-zero value is recognized to mean true.  The
logical and comparison operators allowed in the NEdit macro language are
listed below:
<P>
<PRE>
     &#38;&#38; logical and
     || logical or
     !  not
     &#62;  greater
     &#60;  less
     &#62;= greater or equal
     &#60;= less or equal
     == equal (integers and/or strings)
     != not equal (integers and/or strings)
</PRE>
<P>
<H4>Character String Operators</H4>
<P>
The "operator" for concatenating two strings is the absence of an operator. 
Adjoining character strings with no operator in between means concatenation:
<P>
<PRE>
     d = a b "string" c
     t_print("the value of a is: " a)
</PRE>
<P>
Comparison between character strings is done with the == and != operators,
(as with integers).  There are a number of useful built-in routines for
working with character strings, which are listed in the section called 
"<A HREF="#Macro_Subroutines">Macro Subroutines</A>".
<P>
<H4>Arrays and Array Operators</H4>
<P>
Arrays may contain either strings, integers, or other arrays. Arrays are 
associative, which means that they relate two pieces of information, the key
and  the value. The key is always a string; if you use an integer it is
converted to a string.
<P>
To determine if a given key is in an array, use the 'in' keyword.
<P>
<PRE>
      if ("6" in x)
          &#60;body&#62;
</PRE>
<P>
If the left side of the in keyword is an array, the result is true if every
key in the left array is in the right array. Array values are not compared.
<P>
To iterate through all the keys of an array use the 'for' looping construct.
Keys are not guaranteed in any particular order:
<P>
<PRE>
      for (aKey in x)
          &#60;body&#62;
</PRE>
<P>
Elements can be removed from an array using the delete command:
<P>
<PRE>
      delete x[3] # deletes element with key 3
      delete x[]  # deletes all elements
</PRE>
<P>
The number of elements in an array can be determined by referencing the
array with no indices:
<P>
<PRE>
      dialog("array x has " x[] " elements", "OK")
</PRE>
<P>
Arrays can be combined with some operators. All the following operators only 
compare the keys of the arrays.
<P>
<PRE>
      result = x + y   (Merge arrays)
</PRE>
<P>
The 'result' is a new array containing keys from both x and y. If
duplicates are present values from y are used.
<P>
<PRE>
      result = x - y   (Remove keys)
</PRE>
<P>
The 'result' is a new array containing all keys from x that are not in y.
<P>
<PRE>
      result = x &#38; y   (Common keys)
</PRE>
<P>
The 'result' is a new array containing all keys which are in both x and y.
The values from y are used.
<P>
<PRE>
      result = x | y   (Unique keys)
</PRE>
<P>
The 'result' is a new array containing keys which exist in either x or y, 
but not both.
<P>
When duplicate keys are encountered using the + and &#38; operators, the values 
from the array on the right side of the operators are used for the result.
All  of the above operators are array only, meaning both the left and right
sides of the operator must be arrays. The results are also arrays.
<P>
Array keys can also contain multiple dimensions:
<P>
<PRE>
      x[1, 1, 1] = "string"
</PRE>
<P>
These are used in the expected way, e.g.:
<P>
<PRE>
      for (i = 1; i &#60; 3; i++)
      {
          for (j = 1; j &#60; 3; j++)
          {
              x[i, j] = k++
          }
      }
</PRE>
<P>
gives the following array:
<P>
<PRE>
      x[1, 1] = 0
      x[1, 2] = 1
      x[2, 1] = 2
      x[2, 2] = 3
</PRE>
<P>
Internally all indices are part of one string, separated by the string 
$sub_sep (ASCII 0x18). The first key in the above example is in fact
<P>
<PRE>
      ["1" $sub_sep "1"]
</PRE>
<P>
If you need to extract one of the keys, you can use split(), using 
$sub_sep as the separator.
<P>
You can also check for the existence of multi-dimensional array by 
looking for $sub_sep in the key.
<P>
Last, you need $sub_sep if you want to use the 'in' keyword.
<P>
<PRE>
      if ((1,2) in myArray)
      {..}
</PRE>
<P>
doesn't work, but
<P>
<PRE>
      if (("1" $sub_sep "2") in myArray)
      {..}
</PRE>
<P>
does work.
<P>
<H3>Looping and Conditionals</H3>
<P>
NEdit supports looping constructs: for and while, and conditional statements:
if and else, with essentially the same syntax as C:
<P>
<PRE>
     for (&#60;init&#62;, ...; &#60;condition&#62;; &#60;increment&#62;, ...) &#60;body&#62;
</PRE>
<P>
<PRE>
     while (&#60;condition&#62;) &#60;body&#62;
</PRE>
<P>
<PRE>
     if (&#60;condition&#62;) &#60;body&#62;
</PRE>
<P>
<PRE>
     if (&#60;condition&#62;) &#60;body&#62; else &#60;body&#62;
</PRE>
<P>
&#60;body&#62;, as in C, can be a single statement, or a list of statements enclosed
in curly braces ({}).  &#60;condition&#62; is an expression which must evaluate to
true for the statements in &#60;body&#62; to be executed.  for loops may also contain
initialization statements, &#60;init&#62;, executed once at the beginning of the
loop, and increment/decrement statements (or any arbitrary statement), which
are executed at the end of the loop, before the condition is evaluated again.
<P>
Examples:
<P>
<PRE>
    for (i=0; i&#60;100; i++)
       j = i * 2
</PRE>
<P>
<PRE>
    for (i=0, j=20; i&#60;20; i++, j--) {
       k = i * j
       t_print(i, j, k)
    }
</PRE>
<P>
<PRE>
    while (k &#62; 0)
    {
       k = k - 1
       t_print(k)
    }
</PRE>
<P>
<PRE>
    for (;;) {
       if (i-- &#60; 1)
           break
    }
</PRE>
<P>
Loops may contain break and continue statements.  A break statement causes an
exit from the innermost loop, a continue statement transfers control to the
end of the loop.
<P><HR>
<P>
<A NAME="Macro_Subroutines"</A>
<H2> Macro Subroutines </H2>
<P>
<H3>Built in Variables</H3>
<P>
These variables are read-only and can not be changed.
<P>
<PRE>
<B>$active_pane</B>
</PRE>
Index of the current pane.
<P>
<PRE>
<B>$auto_indent</B>
</PRE>
Contains the current preference for auto indent. 
Can be  "off", "on" or "auto".
<P>
<PRE>
<B>$calltip_ID</B>
</PRE>
Equals the ID of the currently displayed calltip, or 0 if no calltip is
being displayed.
<P>
<PRE>
<B>$cursor</B>
</PRE>
Position of the cursor in the current window.
<P>
<PRE>
<B>$column</B>
</PRE>
Column number of the cursor position in the current window.
<P>
<PRE>
<B>$display_width</B>
</PRE>
Width of the current pane in pixels.
<P>
<PRE>
<B>$em_tab_dist</B>
</PRE>
If tab emulation is turned on in the Tabs...
dialog of the Preferences menu, value is the
distance between emulated tab stops. If tab
emulation is turned off, value is -1.
<P>
<PRE>
<B>$empty_array</B>
</PRE>
An array with no elements. This can be used to initialize 
an array to an empty state.
<P>
<PRE>
<B>$file_format</B>
</PRE>
Current newline format that the file will be saved with. Can 
be "unix", "dos" or "macintosh".
<P>
<PRE>
<B>$file_name</B>
</PRE>
Name of the file being edited in the current
window, stripped of directory component.
<P>
<PRE>
<B>$file_path</B>
</PRE>
Directory component of file being edited in the current window.
<P>
<PRE>
<B>$font_name</B>
</PRE>
Contains the current plain text font name.
<P>
<PRE>
<B>$font_name_bold</B>
</PRE>
Contains the current bold text font name.
<P>
<PRE>
<B>$font_name_bold_italic</B>
</PRE>
Contains the current bold-italic text font name.
<P>
<PRE>
<B>$font_name_italic</B>
</PRE>
Contains the current italic text font name.
<P>
<PRE>
<B>$highlight_syntax</B>
</PRE>
Whether syntax highlighting is turned on.
<P>
<PRE>
<B>$incremental_backup</B>
</PRE>
Contains 1 if incremental auto saving is on, otherwise 0.
<P>
<PRE>
<B>$incremental_search_line</B>
</PRE>
Has a value of 1 if the preference is 
selected to always show the incremental search line, otherwise 0.
<P>
<PRE>
<B>$language_mode</B>
</PRE>
Name of language mode set in the current window.
<P>
<PRE>
<B>$line</B>
</PRE>
Line number of the cursor position in the current window.
<P>
<PRE>
<B>$locked</B>
</PRE>
True if the file has been locked by the user.
<P>
<PRE>
<B>$make_backup_copy</B>
</PRE>
Has a value of 1 if original file is kept in a 
backup file on save, otherwise 0.
<P>
<PRE>
<B>$max_font_width</B>
</PRE>
The maximum font width of all the active styles. 
Syntax highlighting styles are only considered if syntax highlighting 
is turned on.
<P>
<PRE>
<B>$min_font_width</B>
</PRE>
The minimum font width of all the active styles. 
Syntax highlighting styles are only considered if syntax highlighting 
is turned on.
<P>
<PRE>
<B>$modified</B>
</PRE>
True if the file in the current window has
been modified and the modifications have not
yet been saved.
<P>
<PRE>
<B>$n_display_lines</B>
</PRE>
The number of lines visible in the currently active pane.
<P>
<PRE>
<B>$n_panes</B>
</PRE>
The number of panes in the current window.
<P>
<PRE>
<B>$overtype_mode</B>
</PRE>
True if in Overtype mode.
<P>
<PRE>
<B>$read_only</B>
</PRE>
True if the file is read only.
<P>
<PRE>
<B>$selection_start, $selection_end</B>   
</PRE>
Beginning and ending positions of the
primary selection in the current window, or
-1 if there is no text selected in the current window.
<P>
<PRE>
<B>$selection_left, $selection_right</B>  
</PRE>
Left and right character offsets of the rectangular (primary) selection in
the current window, or -1 if there is no selection or it is not rectangular.
<P>
<PRE>
<B>$server_name</B>
</PRE>
Name of the current NEdit server.
<P>
<PRE>
<B>$show_line_numbers</B>
</PRE>
Whether line numbers are shown next to the text.
<P>
<PRE>
<B>$show_matching</B>
</PRE>
Contains the current preference for showing matching pairs, 
such as "[]" and "{}" pairs. Can be "off", "delimiter", or "range".
<P>
<PRE>
<B>$match_syntax_based</B>
</PRE>
Whether pair matching should use syntax information, if available.
<P>
<PRE>
<B>$statistics_line</B>
</PRE>
Has a value of 1 if the statistics line is shown, otherwise 0.
<P>
<PRE>
<B>$sub_sep</B>
</PRE>
Contains the value of the array sub-script separation string.
<P>
<PRE>
<B>$tab_dist</B>
</PRE>
The distance between tab stops for a
hardware tab character, as set in the
Tabs... dialog of the Preferences menu.
<P>
<PRE>
<B>$text_length</B>
</PRE>
The length of the text in the current window.
<P>
<PRE>
<B>$top_line</B>
</PRE>
The line number of the top line of the currently active pane.
<P>
<PRE>
<B>$use_tabs</B>
</PRE>
Whether the user is allowing the NEdit to insert tab characters to maintain
spacing in tab emulation and rectangular dragging operations. (The setting of
the "Use tab characters in padding and emulated tabs" button in the Tabs...
dialog of the Preferences menu.)
<P>
<PRE>
<B>$wrap_margin</B>
</PRE>
The right margin in the current window for text wrapping and filling.
<P>
<PRE>
<B>$wrap_text</B>
</PRE>
The current wrap text mode. Values are "none", "auto" or "continuous".
<P>
<PRE>
<B>$backlight_string</B>
</PRE>
The current value of the window's backlighting specification. This is empty
if backlighting is turned off. It can be changed through calls to the
built-in macro function set_backlight_string().
<P>
<H3>Built-in Subroutines</H3>
<P>
<PRE>
<B>append_file( string, filename )</B>
</PRE>
Appends a string to a named file. Returns 1 on successful write, or 0 if
unsuccessful.
<P>
<PRE>
<B>beep()</B>
</PRE>
Ring the bell.
<P>
<PRE>
<B>calltip( "text_or_key" [, mode [, pos [, position_modifier ...]]] )</B>
</PRE>
Pops up a calltip. &#60;pos&#62; is an optional position in the buffer where the tip
will be displayed.  Passing -1 for &#60;pos&#62; is equivalent to not specifying a 
position, and it guarantees that the tip will appear on-screen somewhere even
if the cursor is not.  The upper-left corner of the calltip will appear below
where the cursor would appear if it were at this position.  &#60;mode&#62; is one of
"tipText" (default), "tipKey", or "tagKey". "tipText" displays the text as-is,
"tagKey" uses it as the key to look up a tag, then converts the tag to a
calltip, and "tipKey" uses it as the key to look up a calltip, then falls back
to "tagKey" behavior if that fails.  You'll usually use "tipKey" or "tipText".
Finally, you can modify the placement of the calltip relative to the cursor
position (or &#60;pos&#62;) with one or more of these optional position modifiers:
"center" aligns the center of the calltip with the position.  "right" aligns
the right edge of the calltip with the position.  ("center" and "right" may 
not both be used.)  "above" places the calltip above the position.  "strict"
does not allow the calltip to move from its position in order to avoid going 
off-screen or obscuring the cursor.  Returns the ID of the calltip if it was 
found and/or displayed correctly, 0 otherwise.
<P>
<PRE>
<B>clipboard_to_string()</B>  
</PRE>
Returns the contents of the clipboard as a macro string. Returns empty
string on error.
<P>
<PRE>
<B>dialog( message, btn_1_label, btn_2_label, ... )</B>  
</PRE>
Pop up a dialog for querying and presenting information to the user. First
argument is a string to show in the message area of the dialog. Up to eight
additional optional arguments represent labels for buttons to appear along
the bottom of the dialog. Returns the number of the button pressed (the
first button is number 1), or 0 if the user closed the dialog via the window
close box.
<P>
<PRE>
<B>focus_window( window_name )</B>  
</PRE>
Sets the window on which subsequent macro commands operate. window_name can
be either a fully qualified file name, or one of "last" for the last window
created, or "next" for the next window in the chain from the currently
focused window (the first window being the one returned from calling
focus_window("last"). Returns the name of the newly-focused window, or an
empty string if the requested window was not found.
<P>
<PRE>
<B>get_character( position )</B>  
</PRE>
Returns the single character at the position
indicated by the first argument to the routine from the current window.
<P>
<PRE>
<B>get_range( start, end )</B>  
</PRE>
Returns the text between a starting and ending position from the current
window.
<P>
<PRE>
<B>get_selection()</B>  
</PRE>
Returns a string containing the text currently selected by the primary
selection either from the current window (no keyword), or from anywhere on
the screen (keyword "any").
<P>
<PRE>
<B>getenv( name )</B>
</PRE>
Gets the value of an environment variable.
<P>
<PRE>
<B>kill_calltip( [calltip_ID] )</B>
</PRE>
Kills any calltip that is being displayed in the window in which the macro is
running.  If there is no displayed calltip this does nothing.  If a calltip
ID is supplied then the calltip is killed only if its ID is calltip_ID.
<P>
<PRE>
<B>length( string )</B>
</PRE>
Returns the length of a string
<P>
<PRE>
<B>list_dialog( message, text, btn_1_label, btn_2_label, ... )</B>  
</PRE>
Pop up a dialog for prompting the user to choose a line from the given text
string. The first argument is a message string to be used as a title for the
fixed text describing the list. The second string provides the list data:
this is a text string in which list entries are separated by newline
characters. Up to seven additional optional arguments represent labels for
buttons to appear along the bottom of the dialog. Returns the line of text
selected by the user as the function value (without any newline separator) or
the empty string if none was selected, and number of the button pressed (the
first button is number 1), in $list_dialog_button. If the user closes the
dialog via the window close box, the function returns the empty string, and
$list_dialog_button returns 0.
<P>
<PRE>
<B>max( n1, n2, ... )</B>
</PRE>
Returns the maximum value of all of its arguments
<P>
<PRE>
<B>min( n1, n2, ... )</B>
</PRE>
Returns the minimum value of all of its arguments
<P>
<PRE>
<B>read_file( filename )</B>  
</PRE>
Reads the contents of a text file into a string. On success, returns 1 in
$read_status, and the contents of the file as a string in the subroutine
return value. On failure, returns the empty string "" and an 0 $read_status.
<P>
<PRE>
<B>replace_in_string( string, search_for, replace_with [, type, "copy"] )</B>  
</PRE>
Replaces all occurrences of a search string in a string with a replacement
string. Arguments are 1: string to search in, 2: string to search for, 3:
replacement string.  There are two optional arguments.  One is a search type, 
either "literal", "case", "word", "caseWord", "regex", or "regexNoCase".  
The default search type is "literal".  If the optional "copy" argument is
specified, a copy of the input string is returned when no replacements were
performed.  By default an empty string ("") will be returned in this case.
Returns a new string with all of the replacements done.
<P>
<PRE>
<B>replace_range( start, end, string )</B>  
</PRE>
Replaces all of the text in the current window between two positions.
<P>
<PRE>
<B>replace_selection( string )</B>  
</PRE>
Replaces the primary-selection selected text in the current window.
<P>
<PRE>
<B>replace_substring( string, start, end, replace_with )</B>  
</PRE>
Replacing a substring between two positions in a string within another string.
<P>
<PRE>
<B>search( search_for, start [, search_type, wrap, direction] )</B>  
</PRE>
Searches silently in a window without dialogs, beeps, or changes to the
selection. Arguments are: 1: string to search for, 2: starting position.
Optional arguments may include the strings: "wrap" to make the search wrap
around the beginning or end of the string, "backward" or "forward" to change
the search direction ("forward" is the default), "literal", "case", "word",
"caseWord", "regex", or "regexNoCase" to change the search  type  (default is
"literal"). Returns the starting position of the  match, or -1 if nothing
matched. Also returns the ending position  of the match in $search_end.
<P>
<PRE>
<B>search_string( string, search_for, start [, search_type, direction] )</B> 
</PRE>
<P>
Built-in macro subroutine for searching a string. Arguments are 1: string to
search in, 2: string to search for, 3: starting position. Optional arguments
may include the strings: "wrap" to make the search wrap around the beginning
or end of the string, "backward" or "forward" to change the search direction
("forward" is the default), "literal", "case", "word", "caseWord", "regex",
or "regexNoCase" to change the search type (default is "literal"). Returns
the starting position of the match, or -1 if nothing matched. Also returns
the ending position of the match in $search_end.
<P>
<PRE>
<B>select( start, end )</B>  
</PRE>
Selects (with the primary selection) text in the current buffer between a
starting and ending position.
<P>
<PRE>
<B>select_rectangle( start, end, left, right )</B>  
</PRE>
Selects a rectangular area of text between a starting and ending position,
and confined horizontally to characters displayed between positions "left",
and "right".
<P>
<PRE>
<B>set_backlight_string( [string] )</B>
</PRE>
Applies the given string, which should be in the format of the
nedit*backlightCharTypes X resource, to the current text window, turning on
backlighting.  If the value of the string passed is "default", or if no
parameter is passed, the nedit.backlightCharTypes X resource's own value will
be used.  If the empty string, "", is passed, backlighting will be turned
off.
<P>
<PRE>
<B>set_cursor_pos( position )</B>
</PRE>
Set the cursor position for the current window.
<P>
<PRE>
<B>shell_command( command, input_string )</B>  
</PRE>
Executes a shell command, feeding it input from input_string. On completion,
output from the command is returned as the function value, and the command's
exit status is returned in the global variable $shell_cmd_status.
<P>
<PRE>
<B>split(string, separation_string [, search_type])</B>
</PRE>
Splits a string using the separator specified. Optionally the search_type
argument can specify how the separation_string is interpreted. The default 
is "literal". The returned value is an array with keys beginning at 0.
<P>
<PRE>
<B>string_dialog( message, btn_1_label, btn_2_label, ... )</B>  
</PRE>
Pops up a dialog prompting the user to enter information. The first argument
is a string to show in the message area of the dialog. Up to nine additional
optional arguments represent labels for buttons to appear along the bottom of
the dialog. Returns the string entered by the user as the function value,
and number of the button pressed (the first button is number 1), in
$string_dialog_button. If the user closes the dialog via the window close
box, the function returns the empty string, and $string_dialog_button returns
0.
<P>
<PRE>
<B>string_compare(string1, string2 [, consider-case])</B>
</PRE>
Compare two  strings and return 0 if they are equal, -1 if string1 is less
than  string2 or 1 if string1 is greater than string2. The values for the
optional consider-case argument is either "case" or "nocase". The default 
is to do a case sensitive comparison.
<P>
<PRE>
<B>string_to_clipboard( string )</B>  
</PRE>
Copy the contents of a macro string to the clipboard.
<P>
<PRE>
<B>substring( string, start, end )</B>  
</PRE>
Returns the portion of a string between a starting and ending position.
<P>
<PRE>
<B>t_print( string1, string2, ... )</B>  
</PRE>
Writes strings to the terminal (stdout) from which NEdit was started.
<P>
<PRE>
<B>tolower( string )</B>
</PRE>
Return an all lower-case version of string.
<P>
<PRE>
<B>toupper( string )</B>
</PRE>
Return an all upper-case version of string.
<P>
<PRE>
<B>write_file( string, filename )</B>  
</PRE>
Writes a string (parameter 1) to a file named in parameter 2. Returns 1 on
successful write, or 0 if unsuccessful.
<P><HR>
<P>
<A NAME="Range_Sets"</A>
<H2> Range Sets </H2>
<P>
The user can define range sets, identified by an alphabetic character.  A
range set contains ranges, defined by start and end positions in the text
buffer.  These ranges are adjusted when modifications are made to the text
buffer: they shuffle around when characters are added or deleted.  However,
ranges within a set will coalesce if the characters between them are removed,
or a new range is added to the set which bridges or overlaps others.
<P>
Using range sets allows non-contiguous bits of the text to be identified as a
group.
<P>
Range sets can be assigned a background color: characters within a range of a
range set will have the background color of the range set. If more than one
rangeset includes a given character, its background color will be that of the
most recently created range set which has a color defined.
<P>
Warnings: A range set is manipulated ONLY through macro routines. Range sets
can easily become very large, and may exceed the capacity of the running
process.  Coloring relies on proper color names or specifications (such as
the "#rrggbb" hexadecimal digit strings), and appropriate hardware support. 
Behaviours set using rangeset_set_modify_response() are still experimental.
<P>
<H3>Range set read-only variables</H3>
<P>
These are set by calls to the range set functions.
<P>
<PRE>
<B>$rangeset_list</B>
</PRE>
string of active rangeset letters in reverse order of definition.
<P>
<PRE>
<B>$rangeset_label</B>
</PRE>
label of most recently accessed rangeset.
<P>
<PRE>
<B>$rangeset_color</B>
</PRE>
color (if any) of most recently accessed rangeset.
<P>
<PRE>
<B>$rangeset_modify_response</B>
</PRE>
modify response name of most recently accessed rangeset.
<P>
<PRE>
<B>$rangeset_ranges</B>
</PRE>
number of ranges in most recently accessed rangeset.
<P>
<PRE>
<B>$rangeset_range_index</B>
</PRE>
most recently accessed range in rangeset (or -1).
<P>
<PRE>
<B>$rangeset_range_start</B>
</PRE>
start position of most recently accessed range (or -1).
<P>
<PRE>
<B>$rangeset_range_end</B>
</PRE>
end position of most recently accessed range (or -1).
<P>
<H3>Range set functions</H3>
<P>
<PRE>
<B>rangeset_defined( r )</B>
</PRE>
Returns true if the range identified by the letter r is defined, false if
not.
<P>
<PRE>
<B>rangeset_inverse( r )</B>
</PRE>
Changes the range set r so that it contains all ranges not in r. Returns the
number of entries if successful.
<P>
<PRE>
<B>rangeset_add( r, [start, end] )</B>
<B>rangeset_add( r, r0 )</B>
</PRE>
Adds to the range set r. The first form adds the range identified by the
current primary selection to the range set, unless start and end are defined,
in which case the range they define is added. The second form allows all
ranges in the range set identified by r0 to be added to the range set r. If r
has not yet been defined, it will be at this point. Returns the number of
non-contiguous ranges in r after the addition.
<P>
<PRE>
<B>rangeset_remove( r, [start, end] )</B>
<B>rangeset_remove( r, r0 )</B>
</PRE>
Removes from the range set r. The first form removes the range identified by
the current primary selection from the range set, unless start and end are
defined, in which case the range they define is removed. The second form
allows all ranges in the range set identified by r0 to be removed from the
range set r. Returns the number of non-contiguous ranges in r after the
addition.
<P>
<PRE>
<B>rangeset_forget( r )</B>
</PRE>
Deletes all information about the range set identified by r. A subsequent
call to rangeset_defined(r) will return false.
<P>
<PRE>
<B>rangeset_get_count( r )</B>
</PRE>
Returns the number of non-contiguous ranges in the range set r.
<P>
<PRE>
<B>rangeset_select( r, [index] )</B>
</PRE>
Selects the region starting at the start of the first range in the range set
r and ending at the end of the last, unless index is supplied, in which case
the range in the range set identified by the index will be selected. index
should satisfy the conditions 0 &#60;= index and index &#60; rangeset_get_count(r).
Returns true if successful.
<P>
<PRE>
<B>rangeset_includes_pos( r, pos )</B>
</PRE>
Returns true if there is a range in the range set r which contains pos.
<P>
<PRE>
<B>rangeset_set_color( r, [color] )</B>
</PRE>
Removes the coloring of range set r if no color name is supplied, otherwise
attempts to apply the color as a background color to the ranges of r. No
check is made regarding the validity of color: if the color is invalid (a bad
name, or not supported by the hardware) this has no effect. If r is
undefined, this function will define it with no ranges.
<P>
<PRE>
<B>rangeset_set_modify_response( r, type )</B>
</PRE>
Changes the behaviour of the range set r when modifications to the text
buffer occur.  type can be one of the following: "maintain" (the default),
"break", "include", "exclude", "ins_del" or "del_ins". (The differences are
fairly subtle.)"
<P>
<A NAME="Highlighting_Information"</A>
<H2> Highlighting Information </H2>
<P>
The user can interrogate the current window to determine the color
highlighting used on a particular piece of text. The following functions
provide information on the highlighting pattern against which text at a
particular position has been matched, its style, color and font attributes
(whether the font is supposed to be bold and/or italic).
<P>
Some other functions allow macros to access style information given the name
of a highlighting pattern, or a highlighting style name.
<P>
These macro functions permit macro writers to generate formatted output which
allows NEdit highlighting to be reproduced. This is suitable for the
generation of HTML or Postscript output, for example.
<P>
<H3>Highlighting information functions</H3>
<P>
<PRE>
<B>get_style( pos )</B>
</PRE>
returns an array containing the attributes of the character at position
"pos". <B>"style"</B> (name of the highlight style), <B>"color"</B> (name of the
color), <B>"rgb"</B> (the actual screen color expressed in red, green and blue
hexadecimal values as "#rrggbb"), <B>"bold"</B> (true or false) and <B>"italic"</B>
(true or false), <B>"background"</B> (name of the background color, if any) and
<B>"back_rgb"</B> (the background color values).
<P>
<PRE>
<B>get_pattern( pos )</B>
</PRE>
returns an array containing the attributes of the character at position
"pos". <B>"pattern"</B> (highlight pattern name), <B>"style"</B> (highlight style
name) and <B>"extension"</B> (the length in the text which uses the same
highlighting pattern) 
<P>
<PRE>
<B>highlight_pattern_of_pos( [pos] )</B>
</PRE>
<I>Deprecated: use get_pattern(pos)["pattern"]</I>
returns the pattern name for highlighting used at the position in the text.
If no position is supplied, the current cursor position will be used.
<P>
<PRE>
<B>highlight_style_of_pos( [pos] )</B>
</PRE>
<I>Deprecated: use either get_pattern(pos)["style"] or get_style(pos)["style"]</I>
returns the name of the highlighting style applied at the given position
(defaults to the cursor position).
<P>
<PRE>
<B>highlight_color_of_pos( [pos] )</B>
</PRE>
<I>Deprecated: use get_style(pos)["color"]</I>
returns the name of the color used by the highlighting style applied at the
given position (defaults to the cursor position).
<P>
<PRE>
<B>highlight_color_value_of_pos( [pos] )</B>
</PRE>
<I>Deprecated: use get_style(pos)["rgb"]</I>
returns the value of the color by the highlighting style applied at the given
position (defaults to the cursor position). This is a hexadecimal formatted
value, preceded by the "#" sign; each of three pairs of hexadecimal digits
indicate the color value for the red, green and blue components of the color,
in the range 0 to 255 (0 - 0xFF), for example "#ffff80" is a light yellow
color.
<P>
<PRE>
<B>highlight_style_of_pos_is_bold( [pos] )</B>
</PRE>
<I>Deprecated: use get_style(pos)["bold"]</I>
returns true (non-zero) if the highlighting style applied at the given
position (defaults to the cursor position) uses a bold font.
<P>
<PRE>
<B>highlight_style_of_pos_is_italic( [pos] )</B>
</PRE>
<I>Deprecated: use get_style(pos)["italic"]</I>
returns true (non-zero) if the highlighting style applied at the given
position (defaults to the cursor position) uses an italic font.
<P>
<PRE>
<B>highlight_pattern_extends_from( [pos] )</B>
</PRE>
<I>Deprecated: use get_pattern(pos)["extension"]</I>
returns the length in the text starting at the given position (defaults to
the cursor position) which uses the same highlighting pattern as that
position.
<P>
<PRE>
<B>highlight_pattern_style( pat_name )</B>
</PRE>
returns the name of the style used by a particular named highlighting
pattern.
<P>
<PRE>
<B>highlight_style_color( style_name )</B>
</PRE>
returns the name of the color used by a particular named highlighting style.
<P>
<PRE>
<B>highlight_style_color_value( style_name )</B>
</PRE>
returns the value of the color used by a particular named highlighting style.
<P>
<PRE>
<B>highlight_style_is_bold( style_name )</B>
</PRE>
returns true (non-zero) if the particular named highlighting style uses a
bold font.
<P>
<PRE>
<B>highlight_style_is_italic( style_name )</B>
</PRE>
returns true (non-zero) if the particular named highlighting style uses an
italic font.
<P><HR>
<P>
<A NAME="Action_Routines"</A>
<H2> Action Routines </H2>
<P>
All of the editing capabilities of NEdit are represented as a special type of
subroutine, called an action routine, which can be invoked from both macros
and translation table entries (see "<A HREF="#Key_Binding">Key Binding</A>" in the
Customizing section of the Help menu).
<P>
<H3>Actions Representing Menu Commands</H3>
<P>
<PRE>
    File Menu                 Search Menu
    -----------------------   -------------------------
    new()                     find()
    open()                    find_dialog()
    open_dialog()             find_again()
    open_selected()           find_selection()
    close()                   replace()
    save()                    replace_dialog()
    save_as()                 replace_all()
    save_as_dialog()          replace_in_selection()
    revert_to_saved()         replace_again()
    include_file()            goto_line_number()
    include_file_dialog()     goto_line_number_dialog()
    load_macro_file()         goto_selected()
    load_macro_file_dialog()  mark()
    load_tags_file()          mark_dialog()
    load_tags_file_dialog()   goto_mark()
    unload_tags_file()        goto_mark_dialog()
    print()                   goto_matching()
    print_selection()         select_to_matching()
    exit()                    find_definition()
</PRE>
<P>
<PRE>
    Edit Menu                 Shell Menu
    -----------------------   -------------------------
    undo()                    filter_selection_dialog()
    redo()                    filter_selection()
    delete()                  execute_command()
    select_all()              execute_command_dialog()
    shift_left()              execute_command_line()
    shift_left_by_tab()       shell_menu_command()
    shift_right()
    shift_right_by_tab()      Macro Menu
    uppercase()               -------------------------
    lowercase()               macro_menu_command()
    fill_paragraph()          repeat_macro()
    control_code_dialog()     repeat_dialog()
</PRE>
<P>
<PRE>
                              Windows Menu
                              -------------------------
                              split_window()
                              close_pane()
</PRE>
<P>
An action representing a menu command is named the same as its corresponding
menu item except that all punctuation is removed, all letters are changed to
lower case, and spaces are replaced with underscores.  To present a dialog to
ask the user for input, use the actions with the `_dialog` suffix. Actions
without the `_dialog` suffix take the information from the routine's
arguments (see below).  
<P>
<H3>Menu Action Routine Arguments</H3>
<P>
Arguments are text strings enclosed in quotes. Below are the menu action
routines which take arguments.  Optional arguments are enclosed in [].
<P>
<PRE>
    <B>close</B>( ["prompt" | "save" | "nosave"] )
</PRE>
<P>
<PRE>
    <B>execute_command</B>( shell-command )
</PRE>
<P>
<PRE>
    <B>filter_selection</B>( shell-command )
</PRE>
<P>
<PRE>
    <B>find</B>( search-string [, <I>search-direction</I>] [, <I>search-type</I>] 
       [, <I>search-wrap</I>] )
</PRE>
<P>
<PRE>
    <B>find_again</B>( [<I>search-direction</I>] [, <I>search-wrap</I>] )
</PRE>
<P>
<PRE>
    <B>find_definition</B>( [tag-name] )
</PRE>
<P>
<PRE>
    <B>find_dialog</B>( [<I>search-direction</I>] [, <I>search-type</I>] 
       [, <I>keep-dialog</I>] )
</PRE>
<P>
<PRE>
    <B>find_selection</B>( [<I>search-direction</I>] [, <I>search-wrap</I>] 
       [, <I>non-regex-search-type</I>] )
</PRE>
<P>
<PRE>
    <B>goto_line_number</B>( [<I>line-number</I>] [, <I>column-number</I>] )
</PRE>
<P>
<PRE>
    <B>goto_mark</B>( <I>mark-letter</I> )
</PRE>
<P>
<PRE>
    <B>include_file</B>( <I>filename</I> )
</PRE>
<P>
<PRE>
    <B>load_tags_file</B>( <I>filename</I> )
</PRE>
<P>
<PRE>
    <B>macro_menu_command</B>( <I>macro-menu-item-name</I> )
</PRE>
<P>
<PRE>
    <B>mark</B>( <I>mark-letter</I> )
</PRE>
<P>
<PRE>
    <B>open</B>( <I>filename</I> )
</PRE>
<P>
<PRE>
    <B>replace</B>( search-string, replace-string, 
       [, <I>search-direction</I>] [, <I>search-type</I>] [, <I>search-wrap</I>] )
</PRE>
<P>
<PRE>
    <B>replace_again</B>( [<I>search-direction</I>] [, <I>search-wrap</I>] )
</PRE>
<P>
<PRE>
    <B>replace_dialog</B>( [<I>search-direction</I>] [, <I>search-type</I>]
       [, <I>keep-dialog</I>] )
</PRE>
<P>
<PRE>
    <B>replace_in_selection</B>( search-string, 
       replace-string [, <I>search-type</I>] )
</PRE>
<P>
<PRE>
    <B>save_as</B>( <I>filename</I> )
</PRE>
<P>
<PRE>
    <B>shell_menu_command</B>( <I>shell-menu-item-name</I> )
</PRE>
<P>
<PRE>
    <B>unload_tags_file</B>( <I>filename</I> )
</PRE>
<P>
<PRE>
    <B>----------- Some notes on argument types above -----------</B>
</PRE>
<P>
<PRE>
    <I>filename</I>       Path names are relative to the directory from
                   which NEdit was started. Shell interpreted 
                   wildcards and `~' are not expanded.
</PRE>
<P>
<PRE>
    <I>keep-dialog</I>    Either "keep" or "nokeep".
</PRE>
<P>
<PRE>
    <I>mark-letter</I>    The mark command limits users to single 
                   letters. Inside of macros, numeric marks are
                   allowed, which won't interfere with marks set
                   by the user.
</PRE>
<P>
<PRE>
    <I>macro-menu-item-name</I>
                   Name of the command exactly as specified in 
                   the Macro Menu dialogs.
</PRE>
<P>
<PRE>
    <I>non-regex-search-type</I> 
                   Either "literal", "case", "word", or 
                   "caseWord".
</PRE>
<P>
<PRE>
    <I>search-direction</I>
                   Either "forward" or "backward".
</PRE>
<P>
<PRE>
    <I>search-type</I>    Either "literal", "case", "word", 
                   "caseWord", "regex", or "regexNoCase".
</PRE>
<P>
<PRE>
    <I>search-wrap</I>    Either "wrap" or "nowrap".
</PRE>
<P>
<PRE>
    <I>shell-menu-item-name</I>
                   Name of the command exactly as specified in 
                   the Shell Menu dialogs.
</PRE>
<P>
<H3>Window Preferences Actions</H3>
<P>
<PRE>
<B>set_auto_indent( "off" | "on" | "smart" )</B>
</PRE>
Set auto indent mode for the current window.
<P>
<PRE>
<B>set_em_tab_dist( em-tab-distance )</B>
</PRE>
Set the emulated tab size. An em-tab-distance value of 
0 or -1 translates to no emulated tabs. Em-tab-distance must 
be smaller than 1000.
<P>
<PRE>
<B>set_fonts( font-name, italic-font-name, bold-font-name, bold-italic-font-name )</B>
</PRE>
Set all the fonts used for the current window.
<P>
<PRE>
<B>set_highlight_syntax( [0 | 1] )</B>
</PRE>
Set syntax highlighting mode for the current window. 
A value of 0 turns it off and a value of 1 turns it on. 
If no parameters are supplied the option is toggled.
<P>
<PRE>
<B>set_incremental_backup( [0 | 1] )</B>
</PRE>
Set incremental backup mode for the current window. 
A value of 0 turns it off and a value of 1 turns it on. 
If no parameters are supplied the option is toggled.
<P>
<PRE>
<B>set_incremental_search_line( [0 | 1] )</B>
</PRE>
Show or hide the incremental search line for the current window. 
A value of 0 turns it off and a value of 1 turns it on. 
If no parameters are supplied the option is toggled.
<P>
<PRE>
<B>set_language_mode( language-mode )</B>
</PRE>
Set the language mode for the current window. If the language mode is 
"" or unrecognized, it will be set to Plain.
<P>
<PRE>
<B>set_locked( [0 | 1] )</B>
</PRE>
This only affects the locked status of a file, not it's read-only 
status. Permissions are NOT changed. 
A value of 0 turns it off and a value of 1 turns it on. 
If no parameters are supplied the option is toggled.
<P>
<PRE>
<B>set_make_backup_copy( [0 | 1] )</B>
</PRE>
Set whether backup copies are made during saves for the current window. 
A value of 0 turns it off and a value of 1 turns it on. 
If no parameters are supplied the option is toggled.
<P>
<PRE>
<B>set_overtype_mode( [0 | 1] )</B>
</PRE>
Set overtype mode for the current window. 
A value of 0 turns it off and a value of 1 turns it on. 
If no parameters are supplied the option is toggled.
<P>
<PRE>
<B>set_show_line_numbers( [0 | 1] )</B>
</PRE>
Show or hide line numbers for the current window. 
A value of 0 turns it off and a value of 1 turns it on. 
If no parameters are supplied the option is toggled.
<P>
<PRE>
<B>set_show_matching( "off" | "delimiter" | "range" )</B>
</PRE>
Set show matching (...) mode for the current window.
<P>
<PRE>
<B>set_match_syntax_based( [0 | 1] )</B>
</PRE>
Set whether matching should be syntax based for the current window.
<P>
<PRE>
<B>set_statistics_line( [0 | 1] )</B>
</PRE>
Show or hide the statistics line for the current window. 
A value of 0 turns it off and a value of 1 turns it on. 
If no parameters are supplied the option is toggled.
<P>
<PRE>
<B>set_tab_dist( tab-distance )</B>
</PRE>
Set the size of hardware tab spacing. Tab-distance must 
must be a value greater than 0 and no greater than 20.
<P>
<PRE>
<B>set_use_tabs( [0 | 1] )</B>
</PRE>
Set whether tabs are used for the current window. 
A value of 0 turns it off and a value of 1 turns it on. 
If no parameters are supplied the option is toggled.
<P>
<PRE>
<B>set_wrap_margin( wrap-width )</B>
</PRE>
Set the wrap width for text wrapping of the current window. A value
of 0 means to wrap at window width.
<P>
<PRE>
<B>set_wrap_text( "none" | "auto" | "continuous" )</B>
</PRE>
Set wrap text mode for the current window.
<P>
<H3>Keyboard-Only Actions</H3>
<P>
In addition to the arguments listed in the call descriptions below, any
routine involving cursor movement can take the argument "extend", meaning,
adjust the primary selection to the new cursor position. Routines which take
the "extend" argument as well as mouse dragging operations for both primary
and secondary selections can take the optional keyword "rect", meaning, make
the selection rectangular. Any routine that accepts the "scrollbar" argument
will move the display but not the cursor or selection. Routines that accept
the "nobell" argument will fail silently without beeping, when that argument
is supplied.
<P>
<PRE>
<B>backward_character( ["nobell"] )</B>
</PRE>
Moves the cursor one character to the left.
<P>
<PRE>
<B>backward_paragraph(["nobell"] )</B>
</PRE>
Moves the cursor to the beginning of the paragraph, or
if the cursor is already at the beginning of a paragraph, moves the cursor to
the beginning of the previous paragraph.  Paragraphs are defined as regions
of text delimited by one or more blank lines.
<P>
<PRE>
<B>backward_word( ["nobell"] )</B>
</PRE>
Moves the cursor to the beginning of a word, or, if the
cursor is already at the beginning of a word, moves the cursor to the
beginning of the previous word.  Word delimiters are user-settable, and
defined by the X resource wordDelimiters.
<P>
<PRE>
<B>beginning_of_file( ["scrollbar"] )</B>
</PRE>
Moves the cursor to the beginning of the file.
<P>
<PRE>
<B>beginning_of_line( ["absolute"] )</B> 
</PRE>
Moves the cursor to the beginning of the line. If
"absolute" is given, always moves to the absolute beginning of line,
regardless of the text wrapping mode.
<P>
<PRE>
<B>beginning_of_selection()</B>
</PRE>
Moves the cursor to the beginning of the selection
without disturbing the selection.
<P>
<PRE>
<B>copy_clipboard()</B>
</PRE>
Copies the current selection to the clipboard.
<P>
<PRE>
<B>copy_primary()</B>
</PRE>
Copies the primary selection to the cursor.
<P>
<PRE>
<B>copy_to()</B>
</PRE>
If a secondary selection exists, copies the secondary selection to
the cursor.  If no secondary selection exists, copies the primary selection
to the pointer location.
<P>
<PRE>
<B>copy_to_or_end_drag()</B>
</PRE>
Completes either a secondary selection operation, or a
primary drag.  If the user is dragging the mouse to adjust a secondary
selection, the selection is copied and either inserted at the cursor
location, or, if pending-delete is on and a primary selection exists in the
window, replaces the primary selection.  If the user is dragging a block of
text (primary selection), completes the drag operation and leaves the text at
it's current location.
<P>
<PRE>
<B>cut_clipboard()</B>
</PRE>
Deletes the text in the primary selection and places it in
the clipboard.
<P>
<PRE>
<B>cut_primary()</B>
</PRE>
Copies the primary selection to the cursor and deletes it at
its original location.
<P>
<PRE>
<B>delete_selection()</B>
</PRE>
Deletes the contents of the primary selection.
<P>
<PRE>
<B>delete_next_character( ["nobell"] )</B>
</PRE>
If a primary selection exists, deletes its contents. 
Otherwise, deletes the character following the cursor.
<P>
<PRE>
<B>delete_previous_character( ["nobell"] )</B>
</PRE>
If a primary selection exists, deletes its
contents.  Otherwise, deletes the character before the cursor.
<P>
<PRE>
<B>delete_next_word( ["nobell"] )</B>
</PRE>
If a primary selection exists, deletes its contents. 
Otherwise, deletes the word following the cursor.
<P>
<PRE>
<B>delete_previous_word( ["nobell"] )</B>
</PRE>
If a primary selection exists, deletes its contents. 
Otherwise, deletes the word before the cursor.
<P>
<PRE>
<B>delete_to_start_of_line( ["nobell", "wrap"] )</B>
</PRE>
If a primary selection exists, deletes its contents.  Otherwise, deletes the
characters between the cursor and the start of the line. If "wrap" is
given, deletes to the previous wrap point or beginning of line, whichever 
is closest.
<P>
<PRE>
<B>delete_to_end_of_line( ["nobell", "absolute"] )</B>
</PRE>
If a primary selection exists, deletes its contents. 
Otherwise, deletes the characters between the cursor and the end of the line.
If "absolute" is given, always deletes to the absolute end of line, regardless
of the text wrapping mode.
<P>
<PRE>
<B>deselect_all()</B>
</PRE>
De-selects the primary selection.
<P>
<PRE>
<B>end_of_file( ["scrollbar"] )</B>
</PRE>
Moves the cursor to the end of the file.
<P>
<PRE>
<B>end_of_line( ["absolute"] )</B> 
</PRE>
Moves the cursor to the end of the line.  If
"absolute" is given, always moves to the absolute end of line, regardless
of the text wrapping mode.
<P>
<PRE>
<B>end_of_selection()</B>
</PRE>
Moves the cursor to the end of the selection without
disturbing the selection.
<P>
<PRE>
<B>exchange( ["nobell"] )</B>
</PRE>
Exchange the primary and secondary selections.
<P>
<PRE>
<B>extend_adjust()</B>
</PRE>
Attached mouse-movement events to begin a selection between
the cursor and the mouse, or extend the primary selection to the mouse
position.
<P>
<PRE>
<B>extend_end()</B>
</PRE>
Completes a primary drag-selection operation.
<P>
<PRE>
<B>extend_start()</B>
</PRE>
Begins a selection between the cursor and the mouse.  A
drag-selection operation can be started with either extend_start or
grab_focus.
<P>
<PRE>
<B>focus_pane( [relative-pane] | [positive-index] | [negative-index] )</B>
</PRE>
Move the focus to the requested pane.
Arguments can be specified in the form of a relative-pane 
("first", "last", "next", "previous"), a positive-index 
(numbers greater than 0, 1 is the same as "first") or a
negative-index (numbers less than 0, -1 is the same as "last").
<P>
<PRE>
<B>forward_character()</B>
</PRE>
Moves the cursor one character to the right.
<P>
<PRE>
<B>forward_paragraph( ["nobell"] )</B>
</PRE>
Moves the cursor to the beginning of the next paragraph. 
Paragraphs are defined as regions of text delimited by one or more blank
lines.
<P>
<PRE>
<B>forward_word( ["tail"] ["nobell"] )</B>
</PRE>
Moves the cursor to the beginning of the next word.  Word
delimiters are user-settable, and defined by the X resource wordDelimiters.
If the "tail" argument is supplied the cursor will be moved to 
the end of the current word or the end of the next word, if the 
cursor is between words.
<P>
<PRE>
<B>grab_focus()</B>
</PRE>
Moves the cursor to the mouse pointer location, and prepares for
a possible drag-selection operation (bound to extend_adjust), or multi-click
operation (a further grab_focus action).  If a second invocation of grab
focus follows immediately, it selects a whole word, or a third, a whole line.
<P>
<PRE>
<B>insert_string( "string" )</B>
</PRE>
If pending delete is on and the cursor is inside the
selection, replaces the selection with "string".  Otherwise, inserts "string"
at the cursor location.
<P>
<PRE>
<B>key_select( "direction" [,"nobell"] )</B>
</PRE>
Moves the cursor one character in "direction"
("left", "right", "up", or "down") and extends the selection.  Same as
forward/backward-character("extend"), or process-up/down("extend"), for
compatibility with previous versions.
<P>
<PRE>
<B>move-destination()</B>
</PRE>
Moves the cursor to the pointer location without
disturbing the selection.  (This is an unusual way of working.  We left it in
for compatibility with previous versions, but if you actually use this
capability, please send us some mail, otherwise it is likely to disappear in
the future.
<P>
<PRE>
<B>move_to()</B>
</PRE>
If a secondary selection exists, deletes the contents of the
secondary selection and inserts it at the cursor, or if pending-delete is on
and there is a primary selection, replaces the primary selection.  If no
secondary selection exists, moves the primary selection to the pointer
location, deleting it from its original position.
<P>
<PRE>
<B>move_to_or_end_drag()</B>
</PRE>
Completes either a secondary selection operation, or a
primary drag.  If the user is dragging the mouse to adjust a secondary
selection, the selection is deleted and either inserted at the cursor
location, or, if pending-delete is on and a primary selection exists in the
window, replaces the primary selection.  If the user is dragging a block of
text (primary selection), completes the drag operation and deletes the text
from it's current location.
<P>
<PRE>
<B>newline()</B>
</PRE>
Inserts a newline character.  If Auto Indent is on, lines up the
indentation of the cursor with the current line.
<P>
<PRE>
<B>newline_and_indent()</B>
</PRE>
Inserts a newline character and lines up the indentation
of the cursor with the current line, regardless of the setting of Auto
Indent.
<P>
<PRE>
<B>newline_no_indent()</B>
</PRE>
Inserts a newline character, without automatic
indentation, regardless of the setting of Auto Indent.
<P>
<PRE>
<B>next_page( ["stutter"] ["column"] ["scrollbar"] ["nobell"] )</B>
</PRE>
Moves the cursor and scroll forward one page.
The parameter "stutter" moves the cursor to the bottom of the display,
unless it is already there, otherwise it will page down.
The parameter "column" will maintain the preferred column while
moving the cursor.
<P>
<PRE>
<B>page_left( ["scrollbar"] ["nobell"] )</B>
</PRE>
Move the cursor and scroll left one page.
<P>
<PRE>
<B>page_right( ["scrollbar"] ["nobell"] )</B>
</PRE>
Move the cursor and scroll right one page.
<P>
<PRE>
<B>paste_clipboard()</B>
</PRE>
Insert the contents of the clipboard at the cursor, or if
pending delete is on, replace the primary selection with the contents of the
clipboard.
<P>
<PRE>
<B>previous_page( ["stutter"] ["column"] ["scrollbar"] ["nobell"] )</B>
</PRE>
Moves the cursor and scroll backward one page.
The parameter "stutter" moves the cursor to the top of the display,
unless it is already there, otherwise it will page up.
The parameter "column" will maintain the preferred column while
moving the cursor.
<P>
<PRE>
<B>process_bdrag()</B>
</PRE>
Same as secondary_or_drag_start for compatibility with previous versions.
<P>
<PRE>
<B>process_cancel()</B>
</PRE>
Cancels the current extend_adjust, secondary_adjust, or
secondary_or_drag_adjust in progress.
<P>
<PRE>
<B>process_down( ["nobell", "absolute"] )</B>
</PRE>
Moves the cursor down one line.  If "absolute" is given, always moves to the 
next line in the text buffer, regardless of wrapping.
<P>
<PRE>
<B>process_return()</B>
</PRE>
Same as newline for compatibility with previous versions.
<P>
<PRE>
<B>process_shift_down( ["nobell", "absolute"] )</B>
</PRE>
Same as process_down("extend") for compatibility with previous versions.
<P>
<PRE>
<B>process_shift_up( ["nobell", "absolute"] )</B>
</PRE>
Same as process_up("extend") for compatibility with previous versions.
<P>
<PRE>
<B>process_tab()</B>
</PRE>
If tab emulation is turned on, inserts an emulated tab,
otherwise inserts a tab character.
<P>
<PRE>
<B>process_up( ["nobell", "absolute"] )</B>
</PRE>
Moves the cursor up one line.  If "absolute" is given, always moves to the 
previous line in the text buffer, regardless of wrapping.
<P>
<PRE>
<B>raise_window([relative-window] | [positive-index] | [negative-index])</B>
</PRE>
Raise the current focused window to the front if no argument is supplied.
Arguments can be specified in the form of a relative-window 
("first", "last", "next", "previous"), a positive-index 
(numbers greater than 0, 1 is the same as "last") or a
negative-index (numbers less than 0, -1 is the same as "first").
<P>
<PRE>
<B>scroll_down(nLines)</B>
</PRE>
Scroll the display down (towards the end of the file) by nLines.
<P>
<PRE>
<B>scroll_left( nPixels )</B>
</PRE>
Scroll the display left by nPixels.
<P>
<PRE>
<B>scroll_right( nPixels )</B>
</PRE>
Scroll the display right by nPixels.
<P>
<PRE>
<B>scroll_up( nLines )</B>
</PRE>
Scroll the display up (towards the beginning of the file) by nLines.
<P>
<PRE>
<B>scroll_to_line( lineNum )</B>
</PRE>
Scroll to position line number lineNum at the top of
the pane.  The first line of a file is line 1.
<P>
<PRE>
<B>secondary_adjust()</B>
</PRE>
Attached mouse-movement events to extend the secondary
selection to the mouse position.
<P>
<PRE>
<B>secondary_or_drag_adjust()</B>
</PRE>
Attached mouse-movement events to extend the
secondary selection, or reposition the primary text being dragged.  Takes two
optional arguments, "copy", and "overlay".  "copy" leaves a copy of the
dragged text at the site at which the drag began.  "overlay" does the drag in
overlay mode, meaning the dragged text is laid on top of the existing text,
obscuring and ultimately deleting it when the drag is complete.
<P>
<PRE>
<B>secondary_or_drag_start()</B>
</PRE>
To be attached to a mouse down event.  Begins drag
selecting a secondary selection, or dragging the contents of the primary
selection, depending on whether the mouse is pressed inside of an existing
primary selection.
<P>
<PRE>
<B>secondary_start()</B>
</PRE>
To be attached to a mouse down event.  Begin drag selecting
a secondary selection.
<P>
<PRE>
<B>select_all()</B>
</PRE>
Select the entire file.
<P>
<PRE>
<B>self_insert()</B>
</PRE>
To be attached to a key-press event, inserts the character
equivalent of the key pressed.
<P>
<P><HR>
<P>
<A NAME="Customizing"</A>
<H1> Customizing </H1>
<P>
<A NAME="Customizing_NEdit"</A>
<H2> Customizing NEdit </H2>
<P>
NEdit can be customized many different ways.  The most important
user-settable options are presented in the Preferences menu, including all
options that users might need to change during an editing session.  Options
set in the Default Settings sub-menu of the Preferences menu can be preserved
between sessions by selecting Save Defaults, which writes the changes to the
preferences file.  See the section titled "<A HREF="#Preferences">Preferences</A>" for more details.
<P>
User defined commands can be added to NEdit's Shell, Macro, and window
background menus.  Dialogs for creating items in these menus can be found
under Customize Menus in the Default Settings sub menu of the Preferences
menu.
<P>
For users who depend on NEdit every day and want to tune every excruciating
detail, there are also X resources for tuning a vast number of such details,
down to the color of each individual button.  See the section "<A HREF="#X_Resources">X Resources</A>"
for more information, as well as a list of selected resources.
<P>
The most common reason customizing your X resources for NEdit, however, is
key binding.  While limited key binding can be done through Preferences
settings (Preferences -&#62; Default Settings -&#62; Customize Menus), you can really
only add keys this way, and each key must have a corresponding menu item. 
Any significant changes to key binding should be made via the Translations
resource and menu accelerator resources.  The sections titled "<A HREF="#Key_Binding">Key Binding</A>"
and "<A HREF="#X_Resources">X Resources</A>" have more information.
<P><HR>
<P>
<A NAME="Preferences"</A>
<H2> Preferences </H2>
<P>
The Preferences menu allows you to set options for both the current editing
window, and default values for newly created windows and future NEdit
sessions.  Options in the Preferences menu itself (not in the Default
Settings sub-menu) take effect immediately and refer to the current window
only.  Options in the Default Settings sub-menu provide initial settings for
future windows created using the New or Open commands; options affecting all
windows are also set here.
Preferences set in the Default Settings sub-menu can be saved in a file that
is automatically read by NEdit at startup time, by selecting Save Defaults.
<P>
<H3>Preferences Menu</H3>
<P>
<PRE>
<B>Default Settings</B>
</PRE>
Menu of initial settings for future windows.  Generally the same as the
options in the main part of the menu, but apply as defaults for future
windows created during this NEdit session.  These settings can be saved using
the Save Defaults command below, to be loaded automatically each time NEdit
is started.
<P>
<PRE>
<B>Save Defaults</B>
</PRE>
Save the default options as set under Default Settings for future NEdit 
sessions.
<P>
<PRE>
<B>Statistics Line</B>
</PRE>
Show the full file name, line number, and length of the file being edited.
<P>
<PRE>
<B>Incremental Search Line</B>
</PRE>
Keep the incremental search bar (Search -&#62; Find Incremental) permanently
displayed at the top of the window.
<P>
<PRE>
<B>Show Line Numbers</B>
</PRE>
Display line numbers to the right of the text.
<P>
<PRE>
<B>Language Mode</B>
</PRE>
Tells NEdit what language (if any) to assume, for selecting language-specific
features such as highlight patterns and smart indent macros, and setting
language specific preferences like word delimiters, tab emulation, and
auto-indent.  See Features for Programming -&#62; <A HREF="#Programming_with_NEdit">Programming with NEdit</A> for
more information.
<P>
<PRE>
<B>Auto Indent</B>
</PRE>
Setting Auto Indent "on" maintains a running indent (pressing the Return key
will line up the cursor with the indent level of the previous line).  If
smart indent macros are available for the current language mode, smart indent
can be selected and NEdit will attempt to guess proper language indentation
for each new line.  See Help -&#62; Features for Programming -&#62; Automatic Indent
for more information.
<P>
<PRE>
<B>Wrap</B>
</PRE>
Choose between two styles of automatic wrapping or none.  Auto Newline wrap,
wraps text at word boundaries when the cursor reaches the right margin, by
replacing the space or tab at the last word boundary with a newline
character.  Continuous Wrap wraps long lines which extend past the right
margin. Continuous Wrap mode is typically used to produce files where
newlines are omitted within paragraphs, to make text filling automatic (a
kind of poor-man's word processor).  Text of this style is common on Macs and
PCs but is not necessarily supported very well under Unix (except in programs
which deal with e-mail, for which it is often the format of choice).
<P>
<PRE>
<B>Wrap Margin</B>
</PRE>
Set margin for Auto Newline Wrap, Continuous Wrap, and Fill Paragraph.  Lines
may, be wrapped at the right margin of the window, or the margin can be set
at a specific column.
<P>
<PRE>
<B>Tabs</B>
</PRE>
Set the tab distance (number of characters between tab stops) for tab
characters, and control tab emulation and use of tab characters in padding
and emulated tabs.
<P>
<PRE>
<B>Text Font...</B>
</PRE>
Change the font(s) used to display text (fonts for menus and dialogs must be
set using X resources for the text area of the window). See below for more
information.
<P>
<PRE>
<B>Highlight Syntax</B>
</PRE>
If NEdit recognizes the language being edited, and highlighting patterns are
available for that language, use fonts and colors to enhance viewing of the
file.  (See Help -&#62; Features for Programming -&#62; Syntax Highlighting for more
information.
<P>
<PRE>
<B>Make Backup Copy</B>
</PRE>
On Save, write a backup copy of the file as it existed before the Save
command with the extension .bck (Unix only).
<P>
<PRE>
<B>Incremental Backup</B>
</PRE>
Periodically make a backup copy of the file being edited under the name
`~filename` on Unix or `_filename` on VMS (see <A HREF="#Crash_Recovery">Crash Recovery</A>).
<P>
<PRE>
<B>Show Matching (..)</B>
</PRE>
Momentarily highlight matching parenthesis, brackets, and braces, or the
range between them, when one of these characters is typed, or when the
insertion cursor is positioned after it. Delimiter only highlights the
matching delimiter, while Range highlights the whole range of text between
the matching delimiters.
<P>
Optionally, the matching can make use of syntax information if syntax
highlighting is enabled. Alternatively, the matching is purely character
based. In general, syntax based matching results in fewer false matches.
<P>
<PRE>
<B>Overtype</B>
</PRE>
In overtype mode, new characters entered replace the characters in front of
the insertion cursor, rather than being inserted before them.
<P>
<PRE>
<B>Read Only</B>
</PRE>
Lock the file against accidental modification.  This temporarily prevents the
file from being modified in this NEdit session. Note that this is different
from setting the file protection.
<P>
<H3>Preferences -> Default Settings Menu</H3>
<P>
Options in the Preferences -&#62; Default Settings menu have the same meaning as
those in the top-level Preferences menu, except that they apply to future
NEdit windows and future NEdit sessions if saved with the Save Defaults
command.  Additional options which appear in this menu are:
<P>
<PRE>
<B>Language Modes</B>
</PRE>
Define language recognition information (for determining language mode from
file name or content) and set language specific preferences.
<P>
<PRE>
<B>Tag Collisions</B>
</PRE>
How to react to multiple tags for the same name.  Tags are described in the
section: Features for Programmers -&#62; Finding Declarations (ctags).  In Show
All mode, all matching tags are displayed in a dialog.  In Smart mode, if one
of the matching tags is in the current window, that tag is chosen, without
displaying the dialog.
<P>
<PRE>
<B>Customize Menus</B>
</PRE>
Add/remove items from the Shell, Macro, and window background menus (see
below).
<P>
<PRE>
<B>Customize Window Title</B>
</PRE>
Opens a dialog where the information to be displayed in the windows's title
field can be defined and tested. The dialog contains a Help button, providing
further information about the options available.
<P>
<PRE>
<B>Searching</B>
</PRE>
Options for controlling the behavior of Find and Replace commands:
<P>
<I>Verbose</I> - 
Presents search results in dialog form, asks before wrapping a
search back around the beginning (or end) of the file 
(unless Beep On Search Wrap is turned on).
<P>
<I>Wrap Around</I> - 
Search and Replace operations wrap around the beginning (or end) of the file.
<P>
<I>Beep On Search Wrap</I> - 
Beep when Search and Replace operations wrap around the beginning (or end) of
the file (only if Wrap Around is turned on).
<P>
<I>Keep Dialogs Up</I> - 
Don't pop down Replace and Find boxes after searching.
<P>
<I>Default Search Style</I> - 
Initial setting for search type in Find and Replace dialogs.
<P>
<I>Default Replace Scope</I> - 
[THIS OPTION IS ONLY PRESENT WHEN NEDIT WAS COMPILED WITH THE 
<PRE>
   -DREPLACE_SCOPE FLAG TO SELECT AN ALTERNATIVE REPLACE DIALOG LAYOUT.]
</PRE>
<P>
Initial setting for the scope in the Replace/Find dialog, when a selection
exists. It can be either "In Window", "In Selection", or "Smart". "Smart"
results in "In Window" if the size of the selection is smaller than 1 line,
and to "In Selection" otherwise.
<P>
<PRE>
<B>Syntax Highlighting</B>
</PRE>
Program and configure enhanced text display for new or supported languages
(See Features for Programming -&#62; <A HREF="#Syntax_Highlighting">Syntax Highlighting</A>).
<P>
<PRE>
<B>Append Line Feed on Save</B>
</PRE>
Some UNIX tools expect that files end with a line feed. If this option is
activated, NEdit will append one if required.
<P>
<PRE>
<B>Sort Open Prev. Menu</B>
</PRE>
Option to order the File -&#62; Open Previous menu alphabetically, versus in
order of last access.
<P>
<PRE>
<B>Popups Under Pointer</B>
</PRE>
Display pop-up dialogs centered on the current mouse position, as opposed to
centered on the parent window.  This generally speeds interaction, and is
essential for users who users who set their window managers so keyboard focus
follows the mouse.
<P>
<PRE>
<B>Warnings</B>
</PRE>
Options for controlling the popping up of warning dialogs:
<P>
<I>File Modified Externally</I> -
Pop up a warning dialog when files get changed external to NEdit.
<P>
<I>Check Modified File Contents</I> -
If external file modification warnings are requested, also check the file
contents iso. only the modification date.
<P>
<I>Exit Warnings</I> -
Ask before exiting when two or more files are open in an NEdit session.
<P>
<PRE>
<B>Initial Window Size</B>
</PRE>
Default size for new windows.
<P>
<H3>Changing Font(s)</H3>
<P>
The font used to display text in NEdit is set under Preferences -&#62; Text Font
(for the current window), or Preferences -&#62; Default Settings Text Font (for
future windows).  These dialogs also allow you to set fonts for syntax
highlighting.  If you don't intend to use syntax highlighting, you can ignore
most of the dialog, and just set the field labeled Primary Font.
<P>
Unless you are absolutely certain about the types of files that you will be
editing with NEdit, you should choose a fixed-spacing font.  Many, if not
most, plain-text files are written expecting to be viewed with fixed
character spacing, and will look wrong with proportional spacing.  NEdit's
filling, wrapping, and rectangular operations will also work strangely if you
choose a proportional font.
<P>
Note that in the font browser (the dialog brought up by the Browse...
button), the subset of fonts which are shown is narrowed depending on the
characteristics already selected.  It is therefore important to know that you
can unselect characteristics from the lists by clicking on the selected items
a second time.
<P>
Fonts for syntax highlighting should ideally match the primary font in both
height and spacing.  A mismatch in spacing will result in similar distortions
as choosing a proportional font: column alignment will sometimes look wrong,
and rectangular operations, wrapping, and filling will behave strangely.  A
mismatch in height will cause windows to re-size themselves slightly when
syntax highlighting is turned on or off, and increase the inter- line spacing
of the text.  Unfortunately, on some systems it is hard to find sets of fonts
which match exactly in height.
<P>
<H3>Customizing Menus</H3>
<P>
You can add or change items in the Shell, Macro, and window background menus
under Preferences -&#62; Default Settings -&#62; Customize Menus.  When you choose
one of these, you will see a dialog with a list of the current
user-configurable items from the menu on the left.  To change an existing
item, select it from the list, and its properties will appear in the
remaining fields of the dialog, where you may change them.  Selecting the
item "New" from the list allows you to enter new items in the menu.
<P>
Hopefully most of the characteristics are self explanatory, but here are a
few things to note:
<P>
Accelerator keys are keyboard shortcuts which appear on the right hand side
of the menus, and allow you avoid pulling down the menu and activate the
command with a single keystroke.  Enter accelerators by typing the keys
exactly as you would to activate the command.
<P>
Mnemonics are a single letter which should be part of the menu item name,
which allow users to traverse and activate menu items by typing keys when the
menu is pulled down.
<P>
In the Shell Command field of the Shell Commands dialog, the % character
expands to the name (including directory path) of the file in the window.  To
include a % character in the command, use %%.
<P>
The Menu Entry field can contain special characters for constructing
hierarchical sub-menus, and for making items which appear only in certain
language modes.  The right angle bracket character "&#62;" creates a sub-menu. 
The name of the item itself should be the last element of the path formed
from successive sub-menu names joined with "&#62;".  Menu panes are called in to
existence simply by naming them as part of a Menu Entry name.  To put several
items in the same sub-menu, repeat the same hierarchical sequence for each. 
For example, in the Macro Commands dialog, two items with menu entries: a&#62;b&#62;c
and a&#62;b&#62;d would create a single sub menu under the macro menu called "a",
which would contain a single sub-menu, b, holding the actual items, c and d:
<P>
<PRE>
      +---++---++---+
      |a &#62;||b &#62;||c  |
      +---++---+|d  |
                +---+
</PRE>
<P>
To qualify a menu entry with a language mode, simply add an at-sign "@" at
the end of the menu command, followed (no space) by a language mode name.  To
make a menu item which appears in several language modes, append additional
@s and language mode names.  For example, an item with the menu entry:
<P>
<PRE>
    Make C Prototypes@C@C++
</PRE>
<P>
would appear only in C and C++ language modes, and:
<P>
<PRE>
    Make Class Template@C++
</PRE>
<P>
would appear only in C++ mode.
<P>
Menu items with no qualification appear in all language modes.
<P>
If a menu item is followed by the single language qualification "@*", that
item will appear only if there are no applicable language-specific items of
the same name in the same submenu.  For example, if you have the following
three entries in the same menu:
<P>
<PRE>
    Make Prototypes@C@C++
    Make Prototypes@Java
    Make Prototypes@*
</PRE>
<P>
The first will be available when the language mode is C or C++, the second
when the language mode is Java, and for all other language modes (including
the "Plain" non-language mode).  If the entry:
<P>
<PRE>
    Make Prototypes
</PRE>
<P>
also exists, this will always appear, meaning that the menu will always have
two "Make Prototypes" entries, whatever the language mode.
<P>
<H3>The NEdit Preferences File</H3>
<P>
The NEdit saved preferences file is an X resource file, and its contents can
be moved into another X resource file (see <A HREF="#X_Resources">X Resources</A>).  One reason for
doing so would be to attach server specific preferences, such as a default
font to a particular X server.  Another reason for moving preferences into the
X resource file would be to keep preferences menu options and resource
settable options together in one place.
Though the files are the same format, additional resources should not be added
to the preference file since NEdit modifies this file by overwriting it
completely.  Note also that the contents of the preference file take
precedence over the values of X resources.
Using Save Defaults after moving the contents of your preference file to your
.Xdefaults file will re-create the preference file, interfering with the
options that you have moved.
The location of NEdit's preferences file depends on your environment:
<P>
<UL>
    <li>The default place for the file is '$HOME/.nedit/nedit.rc',</li>
    <li>if the variable $NEDIT_HOME is set in your environment it is located at '$NEDIT_HOME/nedit.rc',</li>
    <li>you may also use old-style run control files; in this case, the preferences are stored in $HOME/.nedit.</li>
</UL>
<P>
(For VMS, the file is in '$NEDIT_HOME/nedit.rc' if $NEDIT_HOME is set, in
'SYS$LOGIN:.nedit' otherwise.)
<P>
<H3>Sharing Customizations with Other NEdit Users</H3>
<P>
If you have written macro or shell menu commands, highlight patterns, or
smart-indent macros that you want to share with other NEdit users, you can
make a file which they can load into their NEdit environment.
<P>
To load such a file, start NEdit with the command:
<P>
<PRE>
     nedit -import &#60;file&#62;
</PRE>
<P>
In the new NEdit session, verify that the imported patterns or macros do what
you want, then select Preferences -&#62; Save Defaults.  Saving incorporates the
changes into the nedit preferences file, so the next time you run NEdit, you
will not have to import the distribution file.
<P>
Loading a customization file is automated, but creating one is not.  To
produce a file to be imported by other users, you must make a copy of your own
NEdit configuration file, and edit it, by hand, to remove everything but the
few items of interest to the recipient.  Leave only the individual
resource(s), and within those resources, only the particular macro, pattern,
style, etc, that you wish to exchange.
<P>
For example, to share a highlighting pattern set, you would include the
patterns, any new styles you added, and language mode information only if the
patterns are intended to support a new language rather than updating an
existing one. For example:
<P>
<PRE>
     nedit.highlightPatterns:\
          My Language:1:0{\n\
                  Comment:"#":"$"::Comment::\n\
                  Loop Header:"^[ \\t]*loop:":::Loop::\n\
          }
     nedit.languageModes: My Language:.my::::::
     nedit.styles: Loop:blue:Bold
</PRE>
<P>
Resources are in the format of X resource files, but the format of text
within multiple-item resources like highlight patterns, language modes,
macros, styles, etc., are private to NEdit.  Each resource is a string which
ends at the first newline character not escaped with \, so you must be
careful about how you treat ends of lines.  While you can generally just cut
and paste indented sections, if something which was originally in the middle
of a resource string is now at the end, you must remove the \ line
continuation character(s) so it will not join the next line into the
resource.  Conversely, if something which was originally at the end of a
resource is now in the middle, you'll have to add continuation character(s)
to make sure that the resource string is properly continued from beginning to
end, and possibly newline character(s) (\n) to make sure that it is properly
separated from the next item.
<P><HR>
<P>
<A NAME="X_Resources"</A>
<H2> X Resources </H2>
<P>
NEdit has additional options to those provided in the Preferences menu which
are set using X resources.  Like most other X programs, NEdit can be
customized to vastly unnecessary proportions, from initial window positions
down to the font and shadow colors of each individual button (A complete
discussion of how to do this is left to books on the X Windows System).  Key
binding (see "<A HREF="#Key_Binding">Key Binding</A>" is one of the most useful of these resource
settable options.
<P>
X resources are usually specified in a file called .Xdefaults or .Xresources
in your home directory (on VMS this is sys$login:decw$xdefaults.dat).  On
some systems, this file is read and its information attached to the X server
(your screen) when you start X.  On other systems, the .Xdefaults file is
read each time you run an X program.  When X resource values are attached to
the X server, changes to the resource file are not available to application
programs until you either run the xrdb program with the appropriate file as
input, or re-start the X server.
<P>
<H3>Selected X Resource Names</H3>
<P>
The following are selected NEdit resource names and default values for NEdit
options not settable via the Preferences menu (for preference resource names,
see your NEdit preference file):
<P>
<PRE>
<B>nedit.tagFile</B>: (not defined) 
</PRE>
<P>
This can be the name of a file, or multiple files separated by a colon (:)
character, of the type produced by Exuberant Ctags or the Unix ctags
command, which NEdit will load at startup time (see <A HREF="#ctags">ctag support</A> ). The tag
file provides a database from which NEdit can automatically open files
containing the definition of a particular subroutine or data type.
<P>
<PRE>
<B>nedit.alwaysCheckRelativeTagsSpecs: True</B>
</PRE>
<P>
When this resource is set to True, and there are tag files specified (with
the nedit.tagFile resource, see above) as relative paths, NEdit will evaluate
these tag value paths whenever a file is opened. All accessible tag files
will be loaded at this time. When this resource value is False, relative path
tag specifications will only be evaluated at NEdit startup time.
<P>
<PRE>
<B>nedit.shell</B>: /bin/csh 
</PRE>
<P>
(Unix systems only) The Unix shell (command interpreter) to use for executing
commands from the Shell menu
<P>
<PRE>
<B>nedit.wordDelimiters</B>: .,/\\`'!@#%^&#38;*()-=+{}[]":;&#60;&#62;?
</PRE>
<P>
The characters, in addition to blanks and tabs, which mark the boundaries
between words for the move-by-word (Ctrl+Arrow) and select-word (double
click) commands.  Note that this default value may be overridden by the
setting in Preferences -&#62; Default Settings -&#62; Language Modes....
<P>
<PRE>
<B>nedit.remapDeleteKey</B>: False
</PRE>
<P>
Setting this resource to True forcibly maps the delete key to backspace. This
can be helpful on systems where the bindings have become tangled, and in
environments which mix systems with PC style keyboards and systems with DEC
and Macintosh keyboards.  Theoretically, these bindings should be made using
the standard X/Motif mechanisms, outside of NEdit.  In practice, some
environments where users access several different systems remotely, can be
very hard to configure. If you've given up and are using a backspace key
halfway off the keyboard because you can't figure out the bindings, set this
to True.
<P>
<PRE>
<B>nedit.typingHidesPointer</B>: False
</PRE>
<P>
Setting this resource to True causes the mouse pointer to be hidden when you
type in the text area. As soon as the mouse pointer is moved, it will 
reappear.  This is useful to stop the mouse pointer from obscuring text.
<P>
<PRE>
<B>nedit.overrideDefaultVirtualKeyBindings</B>: Auto
</PRE>
<P>
Motif uses a virtual key binding mechanism that shares the bindings between
different Motif applications. When a first Motif application is started, it
installs some default virtual key bindings and any other Motif application 
that runs afterwards, simply reuses them. Obviously, if the first
application installs an invalid set, all others applications may have 
problems.
<P>
In the past, NEdit has been the victim of invalid bindings installed by other 
applications several times. Through this resource, NEdit can be instructed
to ignore the bindings installed by other applications, and use its own
private bindings. By default, NEdit tries to detect invalid bindings
and ignore them automatically (Auto). Optionally, NEdit can be told to
always keep the installed bindings (Never), or to always override them
(Always).
<P>
<PRE>
<B>nedit.stdOpenDialog</B>: False
</PRE>
<P>
Setting this resource to True restores the standard Motif style of Open
dialog.  NEdit file open dialogs are missing a text field at the bottom of
the dialog, where the file name can be entered as a string.  The field is
removed in NEdit to encourage users to type file names in the list, a
non-standard, but much faster method for finding files.
<P>
<PRE>
<B>nedit.bgMenuButton</B>: ~Shift~Ctrl~Meta~Alt&#60;Btn3Down&#62;
</PRE>
<P>
Specification for mouse button / key combination to post the background menu
(in the form of an X translation table event specification).  The event
specification should be as specific as possible, since it will override less
specific translation table entries.
<P>
<PRE>
<B>nedit.maxPrevOpenFiles</B>: 30
</PRE>
<P>
Number of files listed in the Open Previous sub-menu of the File menu.
Setting this to zero disables the Open Previous menu item and maintenance of
the NEdit file history file.
<P>
<PRE>
<B>nedit.printCommand</B>: (system specific)
</PRE>
<P>
Command used by the print dialog to print a file, such as, lp, lpr, etc..
The command must be capable of accepting input via stdin (standard input).
<P>
<PRE>
<B>nedit.printCopiesOption</B>: (system specific)
</PRE>
<P>
Option name used to specify multiple copies to the print command.  If the
option should be separated from its argument by a space, leave a trailing
space. If blank, no "Number of Copies" item will appear in the print dialog.
<P>
<PRE>
<B>nedit.printQueueOption</B>: (system specific)
</PRE>
<P>
Option name used to specify a print queue to the print command.  If the
option should be separated from its argument by a space, leave a trailing
space. If blank, no "Queue" item will appear in the print dialog.
<P>
<PRE>
<B>nedit.printNameOption</B>: (system specific)
</PRE>
<P>
Option name used to specify a job name to the print command.  If the option
should be separated from its argument by a space, leave a trailing space. If
blank, no job or file name will be attached to the print job or banner page.
<P>
<PRE>
<B>nedit.printHostOption</B>: (system specific)
</PRE>
<P>
Option name used to specify a host name to the print command.  If the option
should be separated from its argument by a space, leave a trailing space. If
blank, no "Host" item will appear in the print dialog.
<P>
<PRE>
<B>nedit.printDefaultQueue</B>: (system specific)
</PRE>
<P>
The name of the default print queue.  Used only to display in the print
dialog, and has no effect on printing.
<P>
<PRE>
<B>nedit.visualID</B>: Best
</PRE>
<P>
If your screen supports multiple visuals (color mapping models), this
resource allows you to manually choose among them.  The default value of
"Best" chooses the deepest (most colors) visual available. Since NEdit does
not depend on the specific characteristics of any given color model, Best
probably IS the best choice for everyone, and the only reason for setting
this resource would be to patch around some kind of X server problem. The
resource may also be set to "Default", which chooses the screen's default
visual (often a color-mapped, PseudoColor, visual for compatibility with
older X applications).  It may also be set to a numeric visual-id value (use
xdpyinfo to see the list of visuals supported by your display), or a visual
class name: PseudoColor, DirectColor, TrueColor, etc..
<P>
If you are running under a themed environment (like KDE or CDE) that places
its colors in a shallow visual, and you'd rather have that color scheme
instead of more colors available, then you may need set the visual to
"Default" so that NEdit doesn't choose one with more colors.  (The reason
for this is: if the "best" visual is not the server's default, then NEdit
cannot use the colors provided by your environment.  NEdit will fall back to
its own default color scheme.)
<P>
<PRE>
<B>nedit.installColormap</B>: False
</PRE>
<P>
Force the installation of a private colormap.  If you have a humble 8-bit
color display, and netscape is hogging all of the color cells, you may want
to try turning this on.  On most systems, this will result in colors flashing
wildly when you switch between NEdit and other applications.  But a few
systems (SGI) have hardware support for multiple simultaneous colormaps, and
applications with installed colormaps are well behaved.
<P>
<PRE>
<B>nedit.findReplaceUsesSelection</B>: False
</PRE>
<P>
Controls if the Find and Replace dialogs are automatically loaded with the
contents of the primary selection.
<P>
<PRE>
<B>nedit.stickyCaseSenseButton</B>: True
</PRE>
<P>
Controls if the "Case Sensitive" buttons in the Find and Replace dialogs and
the incremental search bar maintain a separate state for literal and regular
expression searches. Moreover, when set to True, by default literal searches
are case insensitive and regular expression searches are case sensitive. When
set to False, the "Case Sensitive" buttons are independent of the "Regular
Expression" toggle.
<P>
<PRE>
<B>nedit.printDefaultHost</B>: (system specific)
</PRE>
<P>
The node name of the default print host.  Used only to display in the print
dialog, and has no effect on printing.
<P>
<PRE>
<B>nedit.multiClickTime</B>: (system specific)
</PRE>
<P>
Maximum time in milliseconds allowed between mouse clicks within double and
triple click actions.
<P>
<PRE>
<B>nedit*scrollBarPlacement</B>: BOTTOM_LEFT
</PRE>
<P>
How scroll bars are placed in NEdit windows, as well as various lists and
text fields in the program. Other choices are: BOTTOM_RIGHT, TOP_LEFT, or
TOP_RIGHT.
<P>
<PRE>
<B>nedit*text.autoWrapPastedText</B>: False
</PRE>
<P>
When Auto Newline Wrap is turned on, apply automatic wrapping (which
normally only applies to typed text) to pasted text as well.
<P>
<PRE>
<B>nedit*text.foreground</B>: black
</PRE>
<P>
Foreground color of the text editing area of the NEdit window.
<P>
<PRE>
<B>nedit*text.background</B>: white
</PRE>
<P>
Background color of the text editing area of the NEdit window.
<P>
<PRE>
<B>nedit*text.selectForeground</B>: black
</PRE>
<P>
Foreground (text) color for selections in the text editing area of the NEdit
window.
<P>
<PRE>
<B>nedit*text.selectBackground</B>: gray80
</PRE>
<P>
Color for selections in the text editing area of the NEdit window.
<P>
<PRE>
<B>nedit*text.highlightForeground</B>: white
</PRE>
<P>
Foreground (text) color for highlights (parenthesis flashing) in the text
editing area of the NEdit window.
<P>
<PRE>
<B>nedit*text.highlightBackground</B>: red
</PRE>
<P>
Color for highlights (parenthesis flashing) in the text editing area of the
NEdit window.
<P>
<PRE>
<B>nedit*text.cursorForeground</B>: black
</PRE>
<P>
Color for text cursor in the text editing area of the NEdit window.
<P>
<PRE>
<B>nedit*text.lineNumForeground</B>: gray47
</PRE>
<P>
Color for displaying line numbers in the NEdit window.
<P>
<PRE>
<B>nedit*text.heavyCursor</B>: False
</PRE>
<P>
For monitors with poor resolution or users who have difficulty seeing the
cursor, makes the cursor in the text editing area of the window heavier and
darker.
<P>
<PRE>
<B>nedit*text.cursorVPadding</B>: 0
</PRE>
<P>
Number of lines to keep the cursor away from the top or bottom line of the 
window.  Keyboard operations that would cause the cursor to get closer than
this distance cause the window to scroll up or down instead, except at the 
beginning of the file.  Mouse operations are not affected.
<P>
<PRE>
<B>nedit*text.blinkRate</B>: 500
</PRE>
<P>
Blink rate of the text insertion cursor in milliseconds.  Set to zero to stop
blinking.
<P>
<PRE>
<B>nedit*text.Translations</B>:
</PRE>
<P>
Modifies key bindings (see below).
<P>
<PRE>
<B>nedit*foreground</B>: black
</PRE>
<P>
Default foreground color for menus, dialogs, scroll bars, etc..
<P>
<PRE>
<B>nedit*background</B>: #b3b3b3
</PRE>
<P>
Default background color for menus, dialogs, scroll bars, etc..
<P>
<PRE>
<B>nedit*fontList</B>: helvetica medium 12 points
</PRE>
<P>
Default font for menus, dialogs, scroll bars, etc..
<P>
<PRE>
<B>nedit.helpFont</B>: helvetica medium 12 points
</PRE>
<P>
Font used for displaying online help.
<P>
<PRE>
<B>nedit.boldHelpFont</B>: helvetica bold 12 points
</PRE>
<P>
Bold font for online help.
<P>
<PRE>
<B>nedit.italicHelpFont</B>: helvetica italic 12 points
</PRE>
<P>
Italic font for online help.
<P>
<PRE>
<B>nedit.fixedHelpFont</B>: courier medium 12 points
</PRE>
<P>
Fixed font for online help.
<P>
<PRE>
<B>nedit.boldFixedHelpFont</B>: courier bold 12 points
</PRE>
<P>
Fixed bold for online help.
<P>
<PRE>
<B>nedit.italicFixedHelpFont</B>: courier italic 12 points
</PRE>
<P>
Fixed italic font for online help.
<P>
<PRE>
<B>nedit.h1HelpFont</B>: helvetica bold 14 points
</PRE>
<P>
Font for level-1 titles in help text.
<P>
<PRE>
<B>nedit.h2HelpFont</B>: helvetica bold italic 12 points
</PRE>
<P>
Font for level-2 titles in help text.
<P>
<PRE>
<B>nedit.h3HelpFont</B>: courier bold 12 points
</PRE>
<P>
Font for level-3 titles in help text.
<P>
<PRE>
<B>nedit.helpLinkFont</B>: helvetica medium 12 points
</PRE>
<P>
Font for hyperlinks in the help text
<P>
<PRE>
<B>nedit.helpLinkColor</B>: #009900
</PRE>
<P>
Color for hyperlinks in the help text
<P>
<PRE>
<B>nedit.backlightCharTypes</B>:  (undefined)
</PRE>
<P>
A string specifying character classes as ranges of ASCII values followed by
the color to be used as their background colors.  The format is:
<P>
low[-high]{,low[-high]}:color{;low-high{,low[-high]}:color}
<P>
where low and high are ASCII values.
<P>
For example:
<PRE>
    32-255:#f0f0f0;1-31,127:red;128-159:orange;9-13:#e5e5e5
</PRE>
<P>
The macro built-in function set_backlight_string() allows these strings to be
set for a particular window.
<P>
<PRE>
<B>nc.autoStart</B>: True 
</PRE>
<P>
Whether the nc program should automatically start an NEdit server (without
prompting the user) if an appropriate server is not found.
<P>
<PRE>
<B>nc.serverCommand</B>: nedit -server
</PRE>
<P>
Command used by the nc program to start an NEdit server.
<P>
<P><HR>
<I>The following are Selected widget names (to which you may append</I>
<I>.background, .foreground, .fontList, etc., to change colors, fonts</I>
<I> and other characteristics):</I>
<P>
<PRE>
<B>nedit*statsAreaForm</B>
</PRE>
<P>
Statistics line and incremental search bar.  To get consistent results across
the entire stats line and the incremental search bar, use '*' rather than '.'
to separate the resource name.  For example, to set the foreground color of
both components use:  
<PRE>
    nedit*statsAreaForm*foreground
</PRE>
instead of:
<PRE>
    nedit*statsAreaForm.foreground
</PRE>
<P>
<PRE>
<B>nedit*menuBar</B>
</PRE>
<P>
Top-of-window menu-bar.
<P>
<PRE>
<B>nedit*textHorScrollBar</B>
</PRE>
<P>
Horizontal scroll bar.
<P>
<PRE>
<B>nedit*textVertScrollBar</B>
</PRE>
<P>
Vertical scroll bar.
<P>
<PRE>
<B>nedit*calltip</B>
</PRE>
<P>
Calltip pop-ups.
<P><HR>
<P>
<A NAME="Key_Binding"</A>
<H2> Key Binding </H2>
<P>
There are several ways to change key bindings in NEdit.  The easiest way to
add a new key binding in NEdit is to define a macro in Preferences -&#62; Default
Settings -&#62; Customize Menus -&#62; Macro Menu.  However, if you want to change
existing bindings or add a significant number of new key bindings you will
need to do so via X resources.
<P>
Before reading this section, you must understand how to set X resources (see
the help section "<A HREF="#X_Resources">X Resources</A>").  Since setting X resources is tricky, it is
also helpful when working on key-binding, to set some easier-to-verify
resource at the same time, as a simple check that the NEdit program is
actually seeing your changes.  The appres program is also very helpful in
checking that the resource settings that you make, actually reach the program
for which they are intended in the correct form.
<P>
<H3>Key Binding in General</H3>
<P>
Keyboard commands are associated with editor action routines through two
separate mechanisms in NEdit.  Commands which appear in pull-down menus have
individual resources designating a keyboard equivalent to the menu command,
called an accelerator key.  Commands which do not have an associated menu
item are bound to keys via the X toolkit translation mechanism.  The methods
for changing these two kinds of bindings are quite different.
<P>
<H3>Key Binding Via Translations</H3>
<P>
The most general way to bind actions to keys in NEdit is to use the
translation table associated with the text widget.  To add a binding to Alt+Y
to insert the string "Hi!", for example, add lines similar to the following
to your X resource file:
<P>
<PRE>
    NEdit*text.Translations: #override \n\
      Alt&#60;Key&#62;y: insert_string("Hi!") \n
</PRE>
<P>
The Help topic "<A HREF="#Action_Routines">Action Routines</A>" lists the actions available to be bound.
<P>
Translation tables map key and mouse presses, window operations, and other
kinds of events, to actions. The syntax for translation tables is
simplified here, so you may need to refer to a book on the X window system
for more detailed information.
<P>
Note that accelerator resources (discussed below) override translations, and
that most Ctrl+letter and Alt+letter combinations are already bound to an
accelerator key.  To use one of these combinations from a translation table,
therefore, you must first un-bind the original menu accelerator.
<P>
A resource for changing a translation table consists of a keyword; #override,
#augment, or #replace; followed by lines (separated by newline characters)
pairing events with actions.  Events begin with modifiers, like Ctrl, Shift,
or Alt, followed by the event type in &#60;&#62;.  BtnDown, Btn1Down, Btn2Down,
Btn1Up, Key, KeyUp are valid event types.  For key presses, the event type is
followed by the name of the key.  You can specify a combination of events,
such as a sequence of key presses, by separating them with commas.  The other
half of the event/action pair is a set of actions.  These are separated from
the event specification by a colon and from each other by spaces.  Actions
are names followed by parentheses, optionally containing one or more
parameters separated by comas.
<P>
<H3>Changing Menu Accelerator Keys</H3>
<P>
The menu shortcut keys shown at the right of NEdit menu items can also be
changed via X resources.  Each menu item has two resources associated with
it, accelerator, the event to trigger the menu item; and acceleratorText, the
string shown in the menu.  The form of the accelerator resource is the same
as events for translation table entries discussed above, though multiple keys
and other subtleties are not allowed.  The resource name for a menu is the
title in lower case, followed by "Menu", the resource name of menu item is
the name in lower case, run together, with words separated by caps, and all
punctuation removed.  For example, to change Cut to Ctrl+X, you would add the
following to your .Xdefaults file:
<P>
<PRE>
      nedit*editMenu.cut.accelerator: Ctrl&#60;Key&#62;x
      nedit*editMenu.cut.acceleratorText: Ctrl+X
</PRE>
<P>
Accelerator keys with optional shift key modifiers, like Find..., have an
additional accelerator resource with Shift appended to the name.  For
example:
<P>
<PRE>
      nedit*searchMenu.find.acceleratorText: [Shift]Alt+F
      nedit*searchMenu.find.accelerator: Alt&#60;Key&#62;f
      nedit*searchMenu.findShift.accelerator: Shift Alt&#60;Key&#62;f
<P><HR>
</PRE>
<P>
<A NAME="Highlighting_Patterns"</A>
<H2> Highlighting Patterns </H2>
<P>
<H3>Writing Syntax Highlighting Patterns</H3>
<P>
Patterns are the mechanism by which language syntax highlighting is
implemented in NEdit (see <A HREF="#Syntax_Highlighting">Syntax Highlighting</A> under the heading of Features
for Programming). To create syntax highlighting patterns for a new
language, or to modify existing patterns, select "Recognition Patterns" from
"Syntax Highlighting" sub-section of the "Default Settings" sub-menu of the
"Preferences" menu.
<P>
First, a word of caution.  As with regular expression matching in general, it
is quite possible to write patterns which are so inefficient that they
essentially lock up the editor as they recursively re-examine the entire
contents of the file thousands of times.  With the multiplicity of patterns,
the possibility of a lock-up is significantly increased in syntax
highlighting.  When working on highlighting patterns, be sure to save your
work frequently.
<P>
NEdit's syntax highlighting is unusual in that it works in real-time (as you
type), and yet is completely programmable using standard regular expression
notation.  Other syntax highlighting editors usually fall either into the
category of fully programmable but unable to keep up in real-time, or
real-time but limited programmability.  The additional burden that NEdit
places on pattern writers in order to achieve this speed/flexibility mix, is
to force them to state self-imposed limitations on the amount of context that
patterns may examine when re-parsing after a change.  While the "Pattern
Context Requirements" heading is near the end of this section, it is not
optional, and must be understood before making any any serious effort at
pattern writing.
<P>
In its simplest form, a highlight pattern consists of a regular expression to
match, along with a style representing the font an color for displaying any
text which matches that expression.  To bold the word, "highlight", wherever
it appears the text, the regular expression simply would be the word
"highlight".  The style (selected from the menu under the heading of
"Highlight Style") determines how the text will be drawn.  To bold the text,
either select an existing style, such as "Keyword", which bolds text, or
create a new style and select it under Highlight Style.
<P>
The full range of regular expression capabilities can be applied in such a
pattern, with the single caveat that the expression must conclusively match
or not match, within the pre-defined context distance (as discussed below
under Pattern Context Requirements).
<P>
To match longer ranges of text, particularly any constructs which exceed the
requested context, you must use a pattern which highlights text between a
starting and ending regular expression match.  To do so, select "Highlight
text between starting and ending REs" under "Matching", and enter both a
starting and ending regular expression.  For example, to highlight everything
between double quotes, you would enter a double quote character in both the
starting and ending regular expression fields.  Patterns with both a
beginning and ending expression span all characters between the two
expressions, including newlines.
<P>
Again, the limitation for automatic parsing to operate properly is that both
expressions must match within the context distance stated for the pattern
set.
<P>
With the ability to span large distances, comes the responsibility to recover
when things go wrong.  Remember that syntax highlighting is called upon to
parse incorrect or incomplete syntax as often as correct syntax.  To stop a
pattern short of matching its end expression, you can specify an error
expression, which stops the pattern from gobbling up more than it should. 
For example, if the text between double quotes shouldn't contain newlines,
the error expression might be "$".  As with both starting and ending
expressions, error expressions must also match within the requested context
distance.
<P>
<H4>Coloring Sub-Expressions</H4>
<P>
It is also possible to color areas of text within a regular expression
match.  A pattern of this type associates a style with sub-expressions
references of the parent pattern (as used in regular expression substitution
patterns, see the NEdit Help menu item on <A HREF="#Regular_Expressions">Regular Expressions</A>). 
Sub-expressions of both the starting and ending patterns may be colored.  For
example, if the parent pattern has a starting expression "\&#60;", and end
expression "\&#62;", (for highlighting all of the text contained within angle
brackets), a sub-pattern using "&#38;" in both the starting and ending expression
fields could color the brackets differently from the intervening text.  A
quick shortcut to typing in pattern names in the Parent Pattern field is to
use the middle mouse button to drag them from the Patterns list.
<P>
<H4>Hierarchical Patterns</H4>
<P>
A hierarchical sub-pattern, is identical to a top level pattern, but is
invoked only between the beginning and ending expression matches of its
parent pattern.  Like the sub-expression coloring patterns discussed above,
it is associated with a parent pattern using the Parent Pattern field in the
pattern specification.  Pattern names can be dragged from the pattern list
with the middle mouse button to the Parent Pattern field.
<P>
After the start expression of the parent pattern matches, the syntax
highlighting parser searches for either the parent's end pattern or a
matching sub-pattern.  When a sub-pattern matches, control is not returned to
the parent pattern until the entire sub-pattern has been parsed, regardless
of whether the parent's end pattern appears in the text matched by the
sub-pattern.
<P>
The most common use for this capability is for coloring sub-structure of
language constructs (smaller patterns embedded in larger patterns). 
Hierarchical patterns can also simplify parsing by having sub-patterns "hide"
special syntax from parent patterns, such as special escape sequences or
internal comments.
<P>
There is no depth limit in nesting hierarchical sub-patterns, but beyond the
third level of nesting, automatic re-parsing will sometimes have to re-parse
more than the requested context distance to guarantee a correct parse (which
can slow down the maximum rate at which the user can type if large sections
of text are matched only by deeply nested patterns).
<P>
While this is obviously not a complete hierarchical language parser it is
still useful in many text coloring situations.  As a pattern writer, your
goal is not to completely cover the language syntax, but to generate
colorings that are useful to the programmer.  Simpler patterns are usually
more efficient and also more robust when applied to incorrect code.
<P>
<H4>Deferred (Pass-2) Parsing</H4>
<P>
NEdit does pattern matching for syntax highlighting in two passes.  The first
pass is applied to the entire file when syntax highlighting is first turned
on, and to new ranges of text when they are initially read or pasted in.  The
second pass is applied only as needed when text is exposed (scrolled in to
view).
<P>
If you have a particularly complex set of patterns, and parsing is beginning
to add a noticeable delay to opening files or operations which change large
regions of text, you can defer some of that parsing from startup time, to
when it is actually needed for viewing the text.  Deferred parsing can only
be used with single expression patterns, or begin/end patterns which match
entirely within the requested context distance.  To defer the parsing of a
pattern to when the text is exposed, click on the Pass-2 pattern type button
in the highlight patterns dialog.
<P>
Sometimes a pattern can't be deferred, not because of context requirements,
but because it must run concurrently with pass-1 (non-deferred) patterns.  If
they didn't run concurrently, a pass-1 pattern might incorrectly match some
of the characters which would normally be hidden inside of a sequence matched
by the deferred pattern.  For example, C has character constants enclosed in
single quotes.  These typically do not cross line boundaries, meaning they
can be parsed entirely within the context distance of the C pattern set and
should be good candidates for deferred parsing.  However, they can't be
deferred because they can contain sequences of characters which can trigger
pass-one patterns. Specifically, the sequence, '\"', contains a double quote
character, which would be matched by the string pattern and interpreted as
introducing a string.
<P>
<H4>Pattern Context Requirements</H4>
<P>
The context requirements of a pattern set state how much additional text
around any change must be examined to guarantee that the patterns will match
what they are intended to match.  Context requirements are a promise by NEdit
to the pattern writer, that the regular expressions in his/her patterns will
be matched against at least &#60;line context&#62; lines and &#60;character context&#62;
characters, around any modified text.  Combining line and character
requirements guarantee that both will be met.
<P>
Automatic re-parsing happens on EVERY KEYSTROKE, so the amount of context
which must be examined is very critical to typing efficiency.  The more
complicated your patterns, the more critical the context becomes.  To cover
all of the keywords in a typical language, without affecting the maximum rate
at which users can enter text, you may be limited to just a few lines and/or
a few hundred characters of context.
<P>
The default context distance is 1 line, with no minimum character
requirement.  There are several benefits to sticking with this default.  One
is simply that it is easy to understand and to comply with.  Regular
expression notation is designed around single line matching.  To span lines
in a regular expression, you must explicitly mention the newline character
"\n", and matches which are restricted to a single line are virtually immune
to lock-ups.  Also, if you can code your patterns to work within a single
line of context, without an additional character-range context requirement,
the parser can take advantage the fact that patterns don't cross line
boundaries, and nearly double its efficiency over a one-line and 1-character
context requirement.  (In a single line context, you are allowed to match
newlines, but only as the first and/or last character.)
<P><HR>
<P>
<A NAME="Smart_Indent_Macros"</A>
<H2> Smart Indent Macros </H2>
<P>
Smart indent macros can be written for any language, but are usually more
difficult to write than highlighting patterns.  A good place to start, of
course, is to look at the existing macros for C and C++.
<P>
Smart indent macros for a language mode consist of standard NEdit macro
language code attached to any or all of the following three activation
conditions: 1) When smart indent is first turned on for a text window
containing code of the language, 2) When a newline is typed and smart indent
is expected, 3) after any character is typed.  To attach macro code to any of
these code "hooks", enter it in the appropriate section in the Preferences -&#62;
Default Settings -&#62; Auto Indent -&#62; Program Smart Indent dialog.
<P>
Typically most of the code should go in the initialization section, because
that is the appropriate place for subroutine definitions, and smart indent
macros are complicated enough that you are not likely to want to write them
as one monolithic run of code.  You may also put code in the Common/Shared
Initialization section (accessible through the button in the upper left
corner of the dialog).  Unfortunately, since the C/C++ macros also reside in
the common/shared section, when you add code there, you run some risk of
missing out on future upgrades to these macros, because your changes will
override the built-in defaults.
<P>
The newline macro is invoked after the user types a newline, but before the
newline is entered in the buffer.  It takes a single argument ($1) which is
the position at which the newline will be inserted.  It must return the
number of characters of indentation the line should have, or -1.  A return
value of -1 means to do a standard auto-indent.  You must supply a newline
macro, but the code: "return -1" (auto-indent), or "return 0" (no indent) is
sufficient.
<P>
The type-in macro takes two arguments.  $1 is the insert position, and $2 is
the character just inserted, and does not return a value.  You can do just
about anything here, but keep in mind that this macro is executed for every
keystroke typed, so if you try to get too fancy, you may degrade performance.
<P><HR>
<P>
<A NAME="NEdit_Command_Line"</A>
<H2> NEdit Command Line </H2>
<P>
<PRE>
   <B>nedit</B> [-<B>read</B>] [-<B>create</B>] [-<B>line</B> n | +n] [-<B>server</B>]
      [-<B>do</B> command] [-<B>tags</B> file] [-<B>tabs</B> n] [-<B>wrap</B>]
      [-<B>nowrap</B>] [-<B>autowrap</B>] [-<B>autoindent</B>] [-<B>noautoindent</B>]
      [-<B>autosave</B>] [-<B>noautosave</B>] [-<B>rows</B> n] [-<B>columns</B> n]
      [-<B>font</B> font] [-<B>lm</B> languagemode] [-<B>geometry</B> geometry]
      [-<B>iconic</B>] [-<B>noiconic</B>] [-<B>display</B> [host]:server[.screen]
      [-<B>xrm</B> resourcestring] [-<B>svrname</B> name] [-<B>import</B> file]
      [-<B>background</B> color] [-<B>foreground</B> color] [-<B>V</B>|-<B>version</B>]
      [--] [file...]
</PRE>
<P>
<PRE>
<B>-read</B>
</PRE>
Open the file Read Only regardless of the actual file protection.
<P>
<PRE>
<B>-create</B>
</PRE>
Don't warn about file creation when a file doesn't exist.
<P>
<PRE>
<B>-line n (or +n)</B>
</PRE>
Go to line number n
<P>
<PRE>
<B>-server</B>
</PRE>
Designate this session as an NEdit server, for processing commands from the
nc program.  nc can be used to interface NEdit to code development
environments, mailers, etc., or just as a quick way to open files from the
shell command line without starting a new NEdit session.
<P>
<PRE>
<B>-do command</B>
</PRE>
Execute an NEdit macro or action. On each file following the -do argument on
the command line.  -do is particularly useful from the nc program, where nc
-do can remotely execute commands in an NEdit -server session.
<P>
<PRE>
<B>-tags file</B>
</PRE>
Load a file of directions for finding definitions of program subroutines and
data objects.  The file must be of the format gen- erated by Exuberant Ctags,
or the standard Unix ctags command.
<P>
<PRE>
<B>-tabs n</B>
</PRE>
Set tab stops every n characters.
<P>
<PRE>
<B>-wrap, -nowrap</B>
</PRE>
Wrap long lines at the right edge of the window rather than continuing them
past it.  (Continuous Wrap mode)
<P>
<PRE>
<B>-autowrap, -noautowrap</B>
</PRE>
Wrap long lines when the cursor reaches the right edge of the window by
inserting newlines at word boundaries.  (Auto Newline Wrap mode)
<P>
<PRE>
<B>-autoindent, -noautoindent</B>
</PRE>
Maintain a running indent.
<P>
<PRE>
<B>-autosave, -noautosave</B>
</PRE>
Maintain a backup copy of the file being edited under the name '~filename'. 
<P>
<PRE>
<B>-rows n</B>
</PRE>
Default height in characters for an editing window.
<P>
<PRE>
<B>-columns n</B>
</PRE>
Default width in characters for an editing window.
<P>
<PRE>
<B>-font font (or -fn font)</B>
</PRE>
Font for text being edited (Font for menus and dialogs can be set with -xrm
"*fontList:font").
<P>
<PRE>
<B>-lm languagemode</B>
</PRE>
Initial language mode used for editing succeeding files.
<P>
<PRE>
<B>-geometry geometry (or -g geometry)</B>
</PRE>
The initial size and/or location of editor windows.  The argument geometry
has the form:
<P>
<PRE>
   [&#60;width&#62;x&#60;height&#62;][+|-][&#60;xoffset&#62;[+|-]&#60;yoffset&#62;]
</PRE>
<P>
where &#60;width&#62; and &#60;height&#62; are the desired width and height of the window,
and &#60;xoffset&#62; and &#60;yoffset&#62; are the distance from the edge of the screen to
the window, + for top or left, - for bottom or right.  -geometry can be
specified for individual files on the command line.
<P>
<PRE>
<B>-iconic, -noiconic</B>
</PRE>
Initial window state for succeeding files.
<P>
<PRE>
<B>-display [host]:server[.screen]</B>
</PRE>
The name of the X server to use.  host specifies the machine, server
specifies the display server number, and screen specifies the screen number. 
host or screen can be omitted and default to the local machine, and screen 0.
<P>
<PRE>
<B>-background color (or -bg color)</B>
</PRE>
Background color. (background color for text can be set separately with 
-xrm "nedit*text.background: color").
<P>
<PRE>
<B>-foreground color (or -fg color)</B>
</PRE>
Foreground color. (foreground color for text can be set separately with -xrm
"nedit*text.foreground: color").
<P>
<PRE>
<B>-xrm resourcestring</B> 
</PRE>
Set the value of an X resource to override a default
value (see "<A HREF="#Customizing_NEdit">Customizing NEdit</A>").
<P>
<PRE>
<B>-svrname name</B>
</PRE>
When starting NEdit in server mode, name the server, such that it responds to
requests only when nc is given a corresponding -svrname argument.  By naming
servers, you can run several simultaneously, and direct files and commands
specifically to any one.
<P>
<PRE>
<B>-import file</B>
</PRE>
Loads an additional preferences file on top of the existing defaults saved in
your preferences file.  To incorporate macros, language modes, and highlight
patterns and styles written by other users, run NEdit with -import &#60;file&#62;,
then re-save your preference file with Preferences -&#62; Save Defaults.
<P>
<PRE>
<B>-version</B>
</PRE>
Prints out the NEdit version information. The -V option is synonymous.
<P>
<PRE>
<B>--</B>
</PRE>
Treats all subsequent arguments as file names, even if they start with a
dash. This is so NEdit can access files that begin with the dash character.
<P>
<P><HR>
<P>
<A NAME="Client/Server_Mode"</A>
<H2> Client/Server Mode </H2>
<P>
NEdit can be operated on its own, or as a two-part client/server
application.  Client/server mode is useful for integrating NEdit with
software development environments, mailers, and other programs; or just as a
quick way to open files from the shell command line without starting a new
NEdit session.
<P>
To run NEdit in server mode, type:
<P>
<PRE>
      nedit -server
</PRE>
<P>
NEdit can also be started in server mode via the Nedit Client (nc) program
when no servers are available.
<P>
The nc program, which is distributed along with NEdit,
sends commands to an nedit server to open files, select lines, or execute
editor actions.  It accepts a limited set of the nedit command line options:
-read, -create, -line (or +n), -do, and a list of file names.  Listing a file
on the nc command line means, open it if it is not already open and bring the
window to the front.  -read and -create affect only newly opened files, but
-line and -do can also be used on files which are already open 
(See  "<A HREF="#NEdit_Command_Line">NEdit Command Line</A>" for more information).
<P>
In typical Unix style, arguments affect the files which follow them on the
command line, for example:
<P>
<PRE>
      incorrect:   nc file.c -line 25
      correct:     nc -line 25 file.c
</PRE>
<P>
-read, -create, and -line affect all of the files which follow them on the
command line.  The -do macro is executed only once, on the next file on the
line.  -do without a file following it on the command line, executes the
macro on the first available window (presumably when you give a -do command
without a corresponding file or window, you intend it to do something
independent of the window in which it happens to execute).
<P>
nc also accepts one command line option of its own, -noask (or -ask), which
instructs it whether to automatically start a server if one is not
available.  This is also settable via the X resource, nc.autoStart 
(See "<A HREF="#X_Resources">X Resources</A>" section).
<P>
Sometimes it is useful to have more than one NEdit server running, for
example to keep mail and programming work separate.  The option, -svrname, to
both nedit and nc, allows you to start, and communicate with, separate named
servers.  A named server responds only to requests with the corresponding
-svrname argument.  If you use ClearCase and are within a ClearCase view, the
server name will default to the name of the view (based on the value of the
CLEARCASE_ROOT environment variable).
<P>
Communication between nc and nedit is through the X display. So as long as X
windows is set up and working properly, nc will work properly as well. 
nc uses the DISPLAY environment variable, the machine name and your user name
to find the appropriate server, meaning, if you have several machines sharing
a common file system, nc will not be able to find a server that is running on
a machine with a different host name, even though it may be perfectly
appropriate for editing a given file.
<P>
The command which nc uses to start an nedit server is settable via the X
resource nc.serverCommand, by default, "nedit -server".
<P><HR>
<P>
<A NAME="Crash_Recovery"</A>
<H2> Crash Recovery </H2>
<P>
If a system crash, network failure, X server crash, or program error should
happen while you are editing a file, you can still recover most of your
work.  NEdit maintains a backup file which it updates periodically (every 8
editing operations or 80 characters typed).  This file has the same name
as the file that you are editing, but with the character `~' (tilde) on Unix
or `_' (underscore) on VMS prefixed to the name.  To recover a file after a
crash, simply rename the file to remove the tilde or underscore character,
replacing the older version of the file.  (Because several of the Unix shells
consider the tilde to be a special character, you may have to prefix the
character with a `\' (backslash) when you move or delete an NEdit backup
file.)
<P>
Example, to recover the file called "help.c" on Unix type the command:
<P>
<PRE>
      mv \~help.c help.c
</PRE>
<P>
A minor caveat, is that if the file you were editing was in MS DOS format,
the backup file will be in Unix format, and you will need to open the backup
file in NEdit and change the file format back to MS DOS via the Save As...
dialog (or use the Unix unix2dos command outside of NEdit).
<P><HR>
<P>
<A NAME="Version"</A>
<H2> Version </H2>
<P>
<PRE>
NEdit release of Oct 15, 2002
Oct 15, 2002
</PRE>
<P>
NEdit was written by Mark Edel, Joy Kyriakopulos, Christopher Conrad,
Jim Clark, Arnulfo Zepeda-Navratil, Suresh Ravoor, Tony Balinski, Max
Vohlken, Yunliang Yu, Donna Reid, Arne Frlie, Eddy De Greef, Steve
LoBasso, Alexander Mai, Scott Tringali, Thorsten Haude, Steve Haehn,
and Andrew Hood.
<P>
The regular expression matching routines used in NEdit are adapted (with
permission) from original code written by Henry Spencer at the
University of Toronto.
<P>
Syntax highlighting patterns and smart indent macros were contributed by:
Simon T. MacDonald,  Maurice Leysens, Matt Majka, Alfred Smeenk,
Alain Fargues, Christopher Conrad, Scott Markinson, Konrad Bernloehr,
Ivan Herman, Patrice Venant, Christian Denat, Philippe Couton,
Max Vohlken, Markus Schwarzenberg, Himanshu Gohel, Steven C. Kapp,
Michael Turomsha, John Fieber, Chris Ross, Nathaniel Gray, Joachim Lous,
Mike Duigou, Seak Teng-Fong, Joor Loohuis, Mark Jones,
and Niek van den Berg.
<P>
NEdit sources, executables, additional documentation, and contributed
software are available from the NEdit web site at <A HREF="http://www.nedit.org">http://www.nedit.org</A>.
<P>
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
<P>
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License in the Help section "<A HREF="#Distribution_Policy">Distribution Policy</A>" 
for more details.
<P><HR>
<P>
<A NAME="Distribution_Policy"</A>
<H2> Distribution Policy </H2>
<P>
GNU GENERAL PUBLIC LICENSE
<P>
Version 2, June 1991
<P>
Copyright (C) 1989, 1991 Free Software Foundation, Inc. 675 Mass Ave,
Cambridge, MA 02139, USA. Everyone is permitted to copy and distribute
verbatim copies of this license document, but changing it is not allowed.
<P>
Preamble
<P>
The licenses for most software are designed to take away your freedom to
share and change it. By contrast, the GNU General Public License is intended
to guarantee your freedom to share and change free software--to make sure the
software is free for all its users. This General Public License applies to
most of the Free Software Foundation's software and to any other program
whose authors commit to using it. (Some other Free Software Foundation
software is covered by the GNU Library General Public License instead.) You
can apply it to your programs, too.
<P>
When we speak of free software, we are referring to freedom, not price. Our
General Public Licenses are designed to make sure that you have the freedom
to distribute copies of free software (and charge for this service if you
wish), that you receive source code or can get it if you want it, that you
can change the software or use pieces of it in new free programs; and that
you know you can do these things.
<P>
To protect your rights, we need to make restrictions that forbid anyone to
deny you these rights or to ask you to surrender the rights. These
restrictions translate to certain responsibilities for you if you distribute
copies of the software, or if you modify it.
<P>
For example, if you distribute copies of such a program, whether gratis or
for a fee, you must give the recipients all the rights that you have. You
must make sure that they, too, receive or can get the source code. And you
must show them these terms so they know their rights.
<P>
We protect your rights with two steps: (1) copyright the software, and (2)
offer you this license which gives you legal permission to copy, distribute
and/or modify the software.
<P>
Also, for each author's protection and ours, we want to make certain that
everyone understands that there is no warranty for this free software. If the
software is modified by someone else and passed on, we want its recipients to
know that what they have is not the original, so that any problems introduced
by others will not reflect on the original authors' reputations.
<P>
Finally, any free program is threatened constantly by software patents. We
wish to avoid the danger that redistributors of a free program will
individually obtain patent licenses, in effect making the program
proprietary. To prevent this, we have made it clear that any patent must be
licensed for everyone's free use or not licensed at all.
<P>
The precise terms and conditions for copying, distribution and modification
follow.
<P>
GNU GENERAL PUBLIC LICENSE TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND
MODIFICATION
<P>
0. This License applies to any program or other work which contains a notice
placed by the copyright holder saying it may be distributed under the terms
of this General Public License. The "Program", below, refers to any such
program or work, and a "work based on the Program" means either the Program
or any derivative work under copyright law: that is to say, a work containing
the Program or a portion of it, either verbatim or with modifications and/or
translated into another language. (Hereinafter, translation is included
without limitation in the term "modification".) Each licensee is addressed as
"you".
<P>
Activities other than copying, distribution and modification are not covered
by this License; they are outside its scope. The act of running the Program
is not restricted, and the output from the Program is covered only if its
contents constitute a work based on the Program (independent of having been
made by running the Program). Whether that is true depends on what the
Program does.
<P>
1. You may copy and distribute verbatim copies of the Program's source code
as you receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice and
disclaimer of warranty; keep intact all the notices that refer to this
License and to the absence of any warranty; and give any other recipients of
the Program a copy of this License along with the Program.
<P>
You may charge a fee for the physical act of transferring a copy, and you may
at your option offer warranty protection in exchange for a fee.
<P>
2. You may modify your copy or copies of the Program or any portion of it,
thus forming a work based on the Program, and copy and distribute such
modifications or work under the terms of Section 1 above, provided that you
also meet all of these conditions:
<P>
a) You must cause the modified files to carry prominent notices stating
that you changed the files and the date of any change.
<P>
b) You must cause any work that you distribute or publish, that in whole or
in part contains or is derived from the Program or any part thereof, to be
licensed as a whole at no charge to all third parties under the terms of
this License.
<P>
c) If the modified program normally reads commands interactively when run,
you must cause it, when started running for such interactive use in the
most ordinary way, to print or display an announcement including an
appropriate copyright notice and a notice that there is no warranty (or
else, saying that you provide a warranty) and that users may redistribute
the program under these conditions, and telling the user how to view a copy
of this License. (Exception: if the Program itself is interactive but does
not normally print such an announcement, your work based on the Program is
not required to print an announcement.)
<P>
These requirements apply to the modified work as a whole. If identifiable
sections of that work are not derived from the Program, and can be reasonably
considered independent and separate works in themselves, then this License,
and its terms, do not apply to those sections when you distribute them as
separate works. But when you distribute the same sections as part of a whole
which is a work based on the Program, the distribution of the whole must be
on the terms of this License, whose permissions for other licensees extend to
the entire whole, and thus to each and every part regardless of who wrote it.
<P>
Thus, it is not the intent of this section to claim rights or contest your
rights to work written entirely by you; rather, the intent is to exercise the
right to control the distribution of derivative or collective works based on
the Program.
<P>
In addition, mere aggregation of another work not based on the Program with
the Program (or with a work based on the Program) on a volume of a storage or
distribution medium does not bring the other work under the scope of this
License.
<P>
3. You may copy and distribute the Program (or a work based on it, under
Section 2) in object code or executable form under the terms of Sections 1
and 2 above provided that you also do one of the following:
<P>
a) Accompany it with the complete corresponding machine-readable source
code, which must be distributed under the terms of Sections 1 and 2 above
on a medium customarily used for software interchange; or,
<P>
b) Accompany it with a written offer, valid for at least three years, to
give any third party, for a charge no more than your cost of physically
performing source distribution, a complete machine-readable copy of the
corresponding source code, to be distributed under the terms of Sections 1
and 2 above on a medium customarily used for software interchange; or,
<P>
c) Accompany it with the information you received as to the offer to
distribute corresponding source code. (This alternative is allowed only for
noncommercial distribution and only if you received the program in object
code or executable form with such an offer, in accord with Subsection b
above.)
<P>
The source code for a work means the preferred form of the work for making
modifications to it. For an executable work, complete source code means all
the source code for all modules it contains, plus any associated interface
definition files, plus the scripts used to control compilation and
installation of the executable. However, as a special exception, the source
code distributed need not include anything that is normally distributed (in
either source or binary form) with the major components (compiler, kernel,
and so on) of the operating system on which the executable runs, unless that
component itself accompanies the executable.
<P>
If distribution of executable or object code is made by offering access to
copy from a designated place, then offering equivalent access to copy the
source code from the same place counts as distribution of the source code,
even though third parties are not compelled to copy the source along with the
object code.
<P>
4. You may not copy, modify, sublicense, or distribute the Program except as
expressly provided under this License. Any attempt otherwise to copy, modify,
sublicense or distribute the Program is void, and will automatically
terminate your rights under this License. However, parties who have received
copies, or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.
<P>
5. You are not required to accept this License, since you have not signed it.
However, nothing else grants you permission to modify or distribute the
Program or its derivative works. These actions are prohibited by law if you
do not accept this License. Therefore, by modifying or distributing the
Program (or any work based on the Program), you indicate your acceptance of
this License to do so, and all its terms and conditions for copying,
distributing or modifying the Program or works based on it.
<P>
6. Each time you redistribute the Program (or any work based on the Program),
the recipient automatically receives a license from the original licensor to
copy, distribute or modify the Program subject to these terms and conditions.
You may not impose any further restrictions on the recipients' exercise of
the rights granted herein. You are not responsible for enforcing compliance
by third parties to this License.
<P>
7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not excuse
you from the conditions of this License. If you cannot distribute so as to
satisfy simultaneously your obligations under this License and any other
pertinent obligations, then as a consequence you may not distribute the
Program at all. For example, if a patent license would not permit
royalty-free redistribution of the Program by all those who receive copies
directly or indirectly through you, then the only way you could satisfy both
it and this License would be to refrain entirely from distribution of the
Program.
<P>
If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply and
the section as a whole is intended to apply in other circumstances.
<P>
It is not the purpose of this section to induce you to infringe any patents
or other property right claims or to contest validity of any such claims;
this section has the sole purpose of protecting the integrity of the free
software distribution system, which is implemented by public license
practices. Many people have made generous contributions to the wide range of
software distributed through that system in reliance on consistent
application of that system; it is up to the author/donor to decide if he or
she is willing to distribute software through any other system and a licensee
cannot impose that choice.
<P>
This section is intended to make thoroughly clear what is believed to be a
consequence of the rest of this License.
<P>
8. If the distribution and/or use of the Program is restricted in certain
countries either by patents or by copyrighted interfaces, the original
copyright holder who places the Program under this License may add an
explicit geographical distribution limitation excluding those countries, so
that distribution is permitted only in or among countries not thus excluded.
In such case, this License incorporates the limitation as if written in the
body of this License.
<P>
9. The Free Software Foundation may publish revised and/or new versions of
the General Public License from time to time. Such new versions will be
similar in spirit to the present version, but may differ in detail to address
new problems or concerns.
<P>
Each version is given a distinguishing version number. If the Program
specifies a version number of this License which applies to it and "any later
version", you have the option of following the terms and conditions either of
that version or of any later version published by the Free Software
Foundation. If the Program does not specify a version number of this License,
you may choose any version ever published by the Free Software Foundation.
<P>
10. If you wish to incorporate parts of the Program into other free programs
whose distribution conditions are different, write to the author to ask for
permission. For software which is copyrighted by the Free Software
Foundation, write to the Free Software Foundation; we sometimes make
exceptions for this. Our decision will be guided by the two goals of
preserving the free status of all derivatives of our free software and of
promoting the sharing and reuse of software generally.
<P>
<B>NO WARRANTY</B>
<P>
11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE
STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE
PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND
PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE,
YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
<P>
12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO
LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR
THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.
<P>
END OF TERMS AND CONDITIONS
<P><HR>
<P>
<A NAME="Mailing_Lists"</A>
<H2> Mailing Lists </H2>
<P>
There are two separate mailing lists for nedit users, and one for developers.
Users may post to the developer mailing list to report defects and communicate
with the nedit developers.  Remember that nedit is entirely a volunteer
effort, so please ask questions first to the discussion list, and do your
share to answer other users questions as well.
<P>
<PRE>
    <A HREF="mailto:discuss@nedit.org">discuss@nedit.org</A>
</PRE>
<P>
General discussion, questions and answers among NEdit users and developers.
<P>
<PRE>
    <A HREF="mailto:announce@nedit.org">announce@nedit.org</A>
</PRE>
<P>
A low-volume mailing list for announcing new versions.
<P>
<PRE>
    <A HREF="mailto:develop@nedit.org">develop@nedit.org</A>
</PRE>
<P>
Communication among and with NEdit developers.  
Developers should also subscribe to the discuss list.
<P>
To subscribe, send mail to &#60;majordomo@nedit.org&#62; with one or more of the 
following in the body of the message:
<P>
<PRE>
    subscribe announce
    subscribe discuss
    subscribe develop
<P><HR>
</PRE>
<P>
<A NAME="Problems/Defects"</A>
<H2> Problems/Defects </H2>
<P>
<H3>Solutions to Common Problems</H3>
<P>
For a much more comprehensive list of common problems and solutions, see the
NEdit FAQ.  The latest version of the FAQ can always be found on the NEdit
web site at:
<P>
<PRE>
      <A HREF="http://www.nedit.org">http://www.nedit.org</A>.
</PRE>
<P>
<B>P: No files are shown in the "Files" list in the Open... dialog.</B>
<P>
S: When you use the "Filter" field, include the file specification or a
complete directory specification, including the trailing "/" on Unix.  
(See Help in the Open... dialog).
<P>
<B>P: Find Again and Replace Again don't continue in the same direction as the original Find or Replace.</B>
<P>
S: Find Again and Replace Again don't use the direction of the original
search.  The Shift key controls the direction: Ctrl+G means forward,
Shift+Ctrl+G means backward.
<P>
<B>P: Preferences specified in the Preferences menu don't seem to get saved when I select Save Defaults.</B>
<P>
S: NEdit has two kinds of preferences: 1) per-window preferences, in the
Preferences menu, and 2) default settings for preferences in newly created
windows, in the Default Settings sub-menu of the Preferences menu. 
Per-window preferences are not saved by Save Defaults, only Default
Settings.
<P>
<B>P: Columns and indentation don't line up.</B>
<P>
S: NEdit is using a proportional width font.  Set the font to a fixed style
(see Preferences menu).
<P>
<B>P: NEdit performs poorly on very large files.</B>
<P>
S: Turn off Incremental Backup.  With Incremental Backup on, NEdit
periodically writes a full copy of the file to disk.
<P>
<B>P: Commands added to the Shell Commands menu (Unix only) don't output anything until they are finished executing.</B>
<P>
S: If the command output is directed to a dialog, or the input is from a
selection, output is collected together and held until the command
completes.  De-select both of the options and the output will be shown
incrementally as the command executes.
<P>
<B>P: Dialogs don't automatically get keyboard focus when they pop up.</B>
<P>
S: Most X Window managers allow you to choose between two categories of
keyboard focus models: pointer focus, and explicit focus.  Pointer focus
means that as you move the mouse around the screen, the window under the
mouse automatically gets the keyboard focus.  NEdit users who use this
focus model should set "Popups Under Pointer" in the Default Settings sub
menu of the preferences menu in NEdit.  Users with the explicit focus
model, in some cases, may have problems with certain dialogs, such as Find
and Replace.  In MWM this is caused by the mwm resource startupKeyFocus
being set to False (generally a bad choice for explicit focus users). 
NCDwm users should use the focus model "click" instead of "explicit",
again, unless you have set it that way to correct specific problems, this
is the appropriate setting for most explicit focus users.
<P>
<B>P: The Backspace key doesn't work, or deletes forward rather than backward.</B>
<P>
S: While this is an X/Motif binding problem, and should be solved outside of
NEdit in the Motif virtual binding layer (or possibly xmodmap or
translations), NEdit provides an out.  If you set the resource:
nedit.remapDeleteKey to True, NEdit will forcibly map the delete key to
backspace.  The default setting of this resource recently changed, so
users who have been depending on this remapping will now have to set it
explicitly (or fix their bindings).
<P>
<B>P: NEdit crashes when I try to paste text in to a text field in a dialog (like Find or Replace) on my SunOS system.</B>
<P>
S: On many SunOS systems, you have to set up an nls directory before various
inter-client communication features of Motif will function properly. 
There are instructions in README.sun in /pub/v5_0_2/individual/README.sun on 
ftp.nedit.org, as well as a tar file containing a complete nls 
directory: ftp://ftp.nedit.org/pub/v5_0_2/nls.tar. 
README.sun contains directions for setting up an nls directory, which
is required by Motif for handling copy and paste to Motif text fields. 
<P>
<H3>Known Defects</H3>
<P>
Below is the list of known defects which affect NEdit. The defects your copy
of NEdit will exhibit depend on which system you are running and with which
Motif libraries it was built. Note that there are now Motif 1.2 and/or 2.0
libraries available on ALL supported platforms, and as you can see below
there are far fewer defects in Motif 1.2, so it is in your best interest to
upgrade your system.
<P>
<H4>All Versions</H4>
<P>
<PRE>
<B>DEFECT</B>
</PRE>
Operations between rectangular selections on overlapping lines do nothing.
<P>
<PRE>
<I>Work Around</I>
</PRE>
None.  These operations are very complicated and rarely used.
<P>
<PRE>
<B>DEFECT</B>
</PRE>
Cut and Paste menu items fail, or possibly crash, 
for very large (multi-megabyte) selections.
<P>
<PRE>
<I>Work Around</I>
</PRE>
Use selection copy (middle mouse button click) 
for transferring larger quantities of data. 
Cut and Paste save the copied text in server 
memory, which is usually limited.
<P>
<H3>Reporting Defects</H3>
<P>
Submit bugs through the web at:
<P>
<PRE>
    http://sf.net/tracker/?func=add&#38;group_id=11005&#38;atid=111005
</PRE>
<P>
Please include the first few lines from Help &#62; Version, which identifes
NEdit's version and other system attributes important for diagnosing your
problem.
<P>
The NEdit developers subscribe to both discuss@nedit.org and
develop@nedit.org, either of which may be used for reporting defects.  If
you're not sure, or you think the report might be of interest to the general
NEdit user community, send the report to <A HREF="mailto:discuss@nedit.org">discuss@nedit.org</A>.  If it's
something obvious and boring, like we misspelled "anemometer" in the on-line
help, send it to <A HREF="mailto:develop@nedit.org">develop@nedit.org</A>.  If you don't want to subscribe to the
<A HREF="#Mailing_Lists">Mailing Lists</A>, please add a note to your mail about cc'ing you on responses.
<P>
</BODY>
</HTML>
